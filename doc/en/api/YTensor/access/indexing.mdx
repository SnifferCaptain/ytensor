# Element Access: Indexing

This document describes the element access methods for the `YTensor<T, dim>` class, including the `at()` method and `operator[]` subscript access.

## Overview

YTensor provides two primary ways to access elements:

| Method | Syntax | Performance | Safety | Recommended Scenario |
| --- | --- | --- | --- | --- |
| `at()` | `tensor.at(i, j, k)` | High | Bounds checking | Typical access (recommended) |
| `operator[]` | `tensor[i][j][k]` | Lower | Bounds checking | When sub-tensors or Python-style indexing is needed |

---

## The at() Method

### Function Signatures

```cpp
// Variadic parameter version (recommended)
template <typename... Args> 
T& at(const Args... args);

template <typename... Args> 
const T& at(const Args... args) const;

// Vector version
T& at(const std::vector<int>& pos);
const T& at(const std::vector<int>& pos) const;
```

### Parameters

| Name | Type | Description |
| --- | --- | --- |
| `args` | `Args...` | Variadic parameters, each representing an index for a dimension. |
| `pos` | `const std::vector<int>&` | A vector of indices. |

### Core Function Description

Accesses tensor elements via multi-dimensional coordinates. This is the **recommended access method**, as it performs better than `operator[]`.

### Return Value

- **Type**: `T&` or `const T&`
- **Description**: Returns a reference to the element at the specified position.

### Usage Example

```cpp
#include "ytensor_single.hpp"

void example() {
    // Create a 3x4x5 3D tensor
    yt::YTensor<float, 3> tensor(3, 4, 5);
    
    // Method 1: Variadic access (recommended)
    tensor.at(1, 2, 3) = 10.0f;
    float value = tensor.at(1, 2, 3);
    std::cout << value << std::endl;  // Output: 10.0
    
    // Method 2: Using a vector
    std::vector<int> pos = {1, 2, 3};
    tensor.at(pos) = 20.0f;
    std::cout << tensor.at(pos) << std::endl;  // Output: 20.0
    
    // Method 3: Const access
    const auto& const_tensor = tensor;
    float readonly = const_tensor.at(1, 2, 3);
}
```

### Looping for Access

```cpp
yt::YTensor<float, 2> matrix(3, 4);

// Traverse all elements using at()
for (int i = 0; i < matrix.shape(0); ++i) {
    for (int j = 0; j < matrix.shape(1); ++j) {
        matrix.at(i, j) = static_cast<float>(i * 4 + j);
    }
}
```

### Exceptions

- If the number of arguments does not match `dim`, a `std::invalid_argument` exception is thrown (vector version).
- The variadic version checks the number of arguments at compile time.

```cpp
yt::YTensor<float, 3> tensor(3, 4, 5);

// Compile error: Argument count mismatch
// tensor.at(1, 2);  // Compilation fails! Requires 3 arguments

// Runtime error: Vector size mismatch
std::vector<int> wrong_pos = {1, 2};
// tensor.at(wrong_pos);  // Throws an exception!
```

### Performance Characteristics

The `at()` method calculates the memory offset directly, avoiding the creation of intermediate objects:

```cpp
// Pseudo-code implementation
T& at(i, j, k) {
    size_t index = i * stride[0] + j * stride[1] + k * stride[2];
    return data[offset + index];
}
```

---

## operator[] Subscript Access

### Function Signatures

```cpp
// Multi-dimensional tensors (dim > 1): Returns a sub-tensor
YTensor<T, dim - 1> operator[](int index) requires(dim > 1);
const YTensor<T, dim - 1> operator[](int index) const requires(dim > 1);

// One-dimensional tensors (dim == 1): Returns an element
T& operator[](int index) requires(dim == 1);
const T& operator[](int index) const requires(dim == 1);
```

### Parameters

| Name | Type | Description |
| --- | --- | --- |
| `index` | `int` | Index of the first dimension (supports negative indexing). |

### Core Function Description

Accesses tensor elements or sub-tensors using square brackets. Behavior is similar to indexing in NumPy or PyTorch.

### Return Value

- **Multi-dimensional tensors (dim > 1)**: Returns a dimensionality-reduced sub-tensor `YTensor<T, dim-1>`.
- **One-dimensional tensors (dim == 1)**: Returns an element reference `T&`.

### Negative Indexing Support

`operator[]` supports negative indices (circular indexing):

```cpp
tensor[-1]  // Equivalent to tensor[shape[0] - 1]
tensor[-2]  // Equivalent to tensor[shape[0] - 2]
```

Implementation uses modulo arithmetic: `index = (index % shape[0] + shape[0]) % shape[0]`

### Usage Examples

#### Multi-dimensional Tensors

```cpp
#include "ytensor_single.hpp"

void example_multidim() {
    yt::YTensor<float, 3> tensor(3, 4, 5);
    
    // First-level index: returns YTensor<float, 2> with shape [4, 5]
    auto slice1 = tensor[0];
    std::cout << slice1.shape(0) << ", " << slice1.shape(1) << std::endl;  // 4, 5
    
    // Second-level index: returns YTensor<float, 1> with shape [5]
    auto slice2 = tensor[0][1];
    std::cout << slice2.shape(0) << std::endl;  // 5
    
    // Third-level index: returns an element
    float& elem = tensor[0][1][2];
    elem = 10.0f;
    
    // Chained assignment
    tensor[1][2][3] = 20.0f;
    
    // Negative index
    tensor[-1][0][0] = 30.0f;  // Equivalent to tensor[2][0][0]
}
```

#### One-dimensional Tensors

```cpp
void example_1d() {
    yt::YTensor<float, 1> vector(10);
    
    // Direct element access
    vector[0] = 1.0f;
    vector[5] = 5.0f;
    vector[-1] = 10.0f;  // Last element
    
    std::cout << vector[0] << std::endl;   // Output: 1.0
    std::cout << vector[-1] << std::endl;  // Output: 10.0
}
```

### Similarity to Python/NumPy

```cpp
// C++ YTensor
YTensor<float, 3> a(3, 4, 5);
auto sub = a[1][2];
float val = a[1][2][3];

// Python NumPy (Similar)
# a = np.zeros((3, 4, 5))
# sub = a[1][2]
# val = a[1][2][3]
```

### Performance Considerations

:::warning
**Performance Warning**

Each call to `operator[]` creates a new sub-tensor object, involving copying metadata like shape and strides. For frequent access, **prefer the `at()` method**.

```cpp
// ❌ Slower: Multiple temporary objects created
for (int i = 0; i < 1000; ++i) {
    tensor[1][2][3] = i;
}

// ✅ Faster: Direct access
for (int i = 0; i < 1000; ++i) {
    tensor.at(1, 2, 3) = i;
}
```
:::

### Memory Behavior of Sub-tensors

Sub-tensors returned by `operator[]` are **Views** of the original tensor, sharing memory:

```cpp
yt::YTensor<float, 3> a(3, 4, 5);
a.fill(0.0f);

auto sub = a[1];  // sub is a view of a
sub.fill(10.0f);  // Modifying sub also affects a

std::cout << a.at(1, 0, 0) << std::endl;  // Output: 10.0
```

---

## Comparison: at() vs operator[]

| Feature | at() | operator[] |
| --- | --- | --- |
| **Syntax** | `tensor.at(i, j, k)` | `tensor[i][j][k]` |
| **Performance** | ✅ High (direct offset calculation) | ⚠️ Lower (temporary object creation) |
| **Return Type** | Element reference `T&` | Sub-tensor or element |
| **Negative Indexing** | ❌ Not supported | ✅ Supported |
| **Compile-time Check** | ✅ Argument count | ❌ None |
| **Get Sub-tensor** | ❌ Not supported | ✅ Supported |
| **Recommended Case** | Frequent element access | When sub-tensors or negative indices are needed |

---

## Best Practices

### Recommended Usage

```cpp
yt::YTensor<float, 3> tensor(3, 4, 5);

// ✅ Use at() for element access (high performance)
for (int i = 0; i < 3; ++i) {
    for (int j = 0; j < 4; ++j) {
        for (int k = 0; k < 5; ++k) {
            tensor.at(i, j, k) = i + j + k;
        }
    }
}

// ✅ Use operator[] to get sub-tensors
auto slice = tensor[1];  // Get the first slice
slice.fill(10.0f);

// ✅ Use negative indices for end access
float last = tensor[-1][-1][-1];
```

### Usages to Avoid

```cpp
// ❌ Avoid: Multi-level operator[] in loops
for (int i = 0; i < 3; ++i) {
    for (int j = 0; j < 4; ++j) {
        for (int k = 0; k < 5; ++k) {
            tensor[i][j][k] = i + j + k;  // 2 temporary objects created每 each time!
        }
    }
}

// ❌ Avoid: Attempting negative indices with at()
// tensor.at(-1, -1, -1);  // Behavior undefined!
```

### Correct Way to get Sub-tensors

```cpp
// Use operator[] when operating on an entire slice
auto slice = tensor[0];
slice.fill(5.0f);  // Fill the entire slice

// Use at() when accessing individual elements
tensor.at(0, 1, 2) = 10.0f;
```

---

## Full Example

```cpp
#include <iostream>
#include "ytensor_single.hpp"

int main() {
    // Create a 3x4x5 tensor
    yt::YTensor<float, 3> tensor(3, 4, 5);
    
    std::cout << "=== Filling using at() ===" << std::endl;
    // Fill data using at()
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 4; ++j) {
            for (int k = 0; k < 5; ++k) {
                tensor.at(i, j, k) = static_cast<float>(i * 100 + j * 10 + k);
            }
        }
    }
    
    // Read element
    std::cout << "tensor.at(1, 2, 3) = " << tensor.at(1, 2, 3) << std::endl;  // 123.0
    
    std::cout << "\n=== Accessing via operator[] ===" << std::endl;
    // Get sub-tensor
    auto slice = tensor[1];
    std::cout << "slice shape: [" << slice.shape(0) << ", " 
              << slice.shape(1) << "]" << std::endl;  // [4, 5]
    
    // Multi-level indexing
    std::cout << "tensor[1][2][3] = " << tensor[1][2][3] << std::endl;  // 123.0
    
    // Negative index
    std::cout << "tensor[-1][0][0] = " << tensor[-1][0][0] << std::endl;  // 200.0
    
    std::cout << "\n=== Modifying Sub-tensor ===" << std::endl;
    // Modify the entire slice
    auto slice2 = tensor[2];
    slice2.fill(999.0f);
    std::cout << "tensor.at(2, 0, 0) = " << tensor.at(2, 0, 0) << std::endl;  // 999.0
    
    std::cout << "\n=== One-dimensional Tensor ===" << std::endl;
    yt::YTensor<float, 1> vector(10);
    vector[0] = 1.0f;
    vector[9] = 10.0f;
    vector[-1] = 100.0f;  // Overwrites the last element
    
    std::cout << "vector[0] = " << vector[0] << std::endl;    // 1.0
    std::cout << "vector[-1] = " << vector[-1] << std::endl;  // 100.0
    
    return 0;
}
```

---

## Related Content

- [Data Pointer Access](./data_ptr.mdx) - Direct pointer access with `data()`, `atData()`, etc.
- [Iteration Operations](./iteration.mdx) - Batch operations like `foreach()`, `fill()`, etc.
- [Slicing Operations](../shape/slice.mdx) - Advanced slicing and sub-tensor extraction.
- [Performance Optimization](../../guides/performance_tips.mdx) - Optimization tips for access patterns.
