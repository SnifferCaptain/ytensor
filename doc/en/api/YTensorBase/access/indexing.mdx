---
title: Index Access (YTensorBase)
description: Methods for indexing elements in YTensorBase.
---

# Index Access (YTensorBase)

YTensorBase provides templated element access methods that require explicitly specifying the element type `T`.

## Core Methods

### `at` - Multi-dimensional Index Access

### Core Function Description

Accesses an element via its multi-dimensional coordinates (templated version, returns a reference).

#### Function Signatures

```cpp
template <typename T, typename... Args>
T& at(Args... args);

template <typename T>
T& at(const std::vector<int>& pos);

template <typename T>
const T& at(const std::vector<int>& pos) const;
```

#### Template Parameters

| Name | Description |
| --- | --- |
| `T` | **Required**. The element type; must match the tensor's `dtype`. |

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| `args...` | Variadic arguments | Multi-dimensional coordinates (e.g., `at<float>(1, 2, 3)`). |
| `pos` | `const std::vector<int>&` | A coordinate vector. |

#### Return Value

* **Type**: `T&` or `const T&`
* **Description**: Returns a reference to the element at the specified position.

#### Usage Example

```cpp
#include <ytensor.hpp>

void example() {
    YTensorBase tensor({3, 4, 5}, "float32");
    
    // Method 1: Variadic arguments
    tensor.at<float>(1, 2, 3) = 99.0f;
    
    // Method 2: std::vector
    std::vector<int> pos = {1, 2, 3};
    float val = tensor.at<float>(pos);
    
    // const version
    const YTensorBase& constTensor = tensor;
    float val2 = constTensor.at<float>(1, 2, 3);
}
```

#### Implementation Details

```cpp
// Source (src/ytensor_base.inl:513-528)
template <typename T, typename... Args>
inline T& YTensorBase::at(Args... args) {
    std::vector<int> pos = {args...};
    size_t phys = this->toIndex_(pos);  // Calculate physical offset
    return this->data<T>()[phys];
}
```

#### Notes

:::warning
**Type Must Match**
The template parameter `T` must exactly match the tensor's internal `dtype`; otherwise, undefined behavior or runtime errors will occur.

```cpp
YTensorBase tensor({2, 3}, "float32");
tensor.at<float>(0, 0) = 1.0f;   // ✓ Correct
tensor.at<double>(0, 0) = 1.0;   // ✗ Error: Type mismatch
```
:::

:::info
**Physical Offset Calculation**
`at()` internally calls `toIndex_()` to calculate the physical offset (accounting for `_offset` and `_stride`), making it suitable for non-contiguous tensors (such as slices or transposed views).
:::

---

### `atData` - Logical Index Access

### Core Function Description

Accesses an element via its logical (linear) index by converting it into multi-dimensional coordinates.

#### Function Signatures

```cpp
template <typename T>
T& atData(int index);

template <typename T>
const T& atData(int index) const;
```

#### Template Parameters

| Name | Description |
| --- | --- |
| `T` | **Required**. The element type. |

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| `index` | `int` | **Required**. Logical linear index (starting from 0). |

#### Return Value

* **Type**: `T&` or `const T&`
* **Description**: Returns a reference to the element at the specified logical position.

#### Usage Example

```cpp
#include <ytensor.hpp>

void example() {
    YTensorBase tensor({2, 3}, "int32");
    // shape: {2, 3}, logical indices 0-5
    
    // Logical index 5 corresponds to coordinate (1, 2)
    tensor.atData<int>(5) = 99;
    
    // Equivalent to:
    tensor.at<int>(1, 2) = 99;
}
```

#### Implementation Details

```cpp
// Source (src/ytensor_base.inl:530-538)
template <typename T>
inline T& YTensorBase::atData(int index) {
    auto coord = toCoord(index);  // Logical index → Coordinate
    return at<T>(coord);          // Coordinate → Physical offset
}
```

#### Notes

:::warning
**Efficiency Warning**
`atData()` needs to call `toCoord()` to convert the linear index back into coordinates, followed by `at()`. Compared to using `at()` directly, this is less efficient and should only be used in scenarios where logical indexing is truly necessary.
:::

---

## Comparison with YTensor

| Feature | YTensor | YTensorBase |
| --- | --- | --- |
| Type Parameter | Compile-time (Template) | Runtime (`dtype` string) |
| Indexing Syntax | `tensor(i, j)` | `tensor.at<T>(i, j)` |
| Type Check | Compile-time | Runtime (Manual `T` specification) |

```cpp
// YTensor: Compile-time type safety
YTensor<float, 2> yt({2, 3});
yt(0, 1) = 1.5f;  // No template parameter needed

// YTensorBase: Runtime typing
YTensorBase ytb({2, 3}, "float32");
ytb.at<float>(0, 1) = 1.5f;  // Must specify <float>
```

## Full Example

```cpp
#include <ytensor.hpp>
#include <iostream>

int main() {
    YTensorBase tensor({2, 3, 4}, "float32");
    
    // 1. Fill data (using 'at')
    int counter = 0;
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 3; ++j) {
            for (int k = 0; k < 4; ++k) {
                tensor.at<float>(i, j, k) = static_cast<float>(counter++);
            }
        }
    }
    
    // 2. Read data (using 'atData')
    for (int idx = 0; idx < 24; ++idx) {
        float val = tensor.atData<float>(idx);
        std::cout << "Index " << idx << ": " << val << std::endl;
    }
    
    // 3. Non-contiguous tensor (slice)
    YTensorBase sliced = tensor.slice(0, 0, 1);  // First layer, shape {1, 3, 4}
    sliced.at<float>(0, 1, 2) = 999.0f;
    
    // Original tensor is also modified (shared memory)
    std::cout << "Original: " << tensor.at<float>(0, 1, 2) << std::endl;  // 999.0
    
    return 0;
}
```

## Related Documents

- [Data Pointer Access](/api/YTensorBase/access/data_ptr) - Methods like `data<T>()` and `atData_<T>()`.
- [Index Access (YTensor)](/api/YTensor/access/indexing) - `operator()` overload in YTensor.
- [Coordinate Conversion](/api/YTensorBase/utilities/conversion) - Methods like `toIndex()` and `toCoord()`.