# å±æ€§æŸ¥è¯¢

æœ¬æ–‡æ¡£ä»‹ç» YTensor çš„å±æ€§æŸ¥è¯¢æ–¹æ³•ï¼šæ£€æŸ¥å¼ é‡çš„å†…å­˜å¸ƒå±€å’Œå½¢çŠ¶ç‰¹æ€§ã€‚

---

## æ¦‚è¿°

YTensor æä¾›ä»¥ä¸‹å±æ€§æŸ¥è¯¢æ–¹æ³•ï¼š

- **isContiguous()** - æ£€æŸ¥å¼ é‡æ˜¯å¦è¿ç»­
- **isContiguousFrom()** - è·å–è¿ç»­èµ·å§‹ç»´åº¦
- **isDisjoint()** - æ£€æŸ¥å¼ é‡å…ƒç´ æ˜¯å¦ä¸é‡å 
- **shapeMatch()** - æ£€æŸ¥å½¢çŠ¶æ˜¯å¦åŒ¹é…

è¿™äº›æ–¹æ³•ç”¨äºï¼š
- ä¼˜åŒ–ç®—æ³•é€‰æ‹©ï¼ˆè¿ç»­å¼ é‡å¯ä½¿ç”¨ SIMDï¼‰
- å®‰å…¨æ€§æ£€æŸ¥ï¼ˆé¿å…é‡å å†…å­˜ï¼‰
- å½¢çŠ¶éªŒè¯ï¼ˆå¹¿æ’­å‰æ£€æŸ¥ï¼‰

---

## isContiguous()

### å‡½æ•°ç­¾å

```cpp
bool isContiguous(int fromDim = 0) const;
```

### å‚æ•°è¯´æ˜

| å‚æ•°å | ç±»å‹ | é»˜è®¤å€¼ | è¯´æ˜ |
|--------|------|--------|------|
| `fromDim` | `int` | `0` | èµ·å§‹ç»´åº¦ï¼ˆæ”¯æŒè´Ÿæ•°ç´¢å¼•ï¼‰|

### æ ¸å¿ƒåŠŸèƒ½æè¿°

æ£€æŸ¥å¼ é‡ä»æŒ‡å®šç»´åº¦å¼€å§‹æ˜¯å¦åœ¨å†…å­˜ä¸­è¿ç»­å­˜å‚¨ã€‚
åªæ£€æŸ¥ `_shape[i] > 1` çš„ç»´åº¦ï¼ˆå¤§å°ä¸º 1 çš„ç»´åº¦ä¸å½±å“è¿ç»­æ€§ï¼‰ã€‚

### è¿”å›å€¼

- **true**ï¼šä» `fromDim` å¼€å§‹ï¼Œæ‰€æœ‰ç»´åº¦çš„é€»è¾‘æ­¥å¹…ä¸ç‰©ç†æ­¥å¹…ä¸€è‡´
- **false**ï¼šå­˜åœ¨ç»´åº¦çš„é€»è¾‘æ­¥å¹… â‰  ç‰©ç†æ­¥å¹…

### åˆ¤æ–­ç®—æ³•

```cpp
auto logStride = this->stride();  // é€»è¾‘æ­¥å¹…
for (int i = fromDim; i < dim; ++i) {
    if (logStride[i] != _stride[i] && _shape[i] > 1) {
        return false;  // ä¸è¿ç»­
    }
}
return true;  // è¿ç»­
```

**å…³é”®ç‚¹**ï¼šåªæ£€æŸ¥ `_shape[i] > 1` çš„ç»´åº¦ï¼ˆå¤§å°ä¸º 1 çš„ç»´åº¦ä¸å½±å“è¿ç»­æ€§ï¼‰ã€‚

### ä½¿ç”¨ç¤ºä¾‹

#### åŸºæœ¬ç”¨æ³•

```cpp
#include "ytensor_single.hpp"

int main() {
    // æ–°å»ºå¼ é‡ï¼šè¿ç»­
    auto a = yt::YTensor<float, 3>::randn(2, 3, 4);
    std::cout << a.isContiguous() << std::endl;  // true
    
    // è½¬ç½®ï¼šéè¿ç»­
    auto b = a.transpose(0, 1);
    std::cout << b.isContiguous() << std::endl;  // false
    
    // åˆ‡ç‰‡ï¼šå¯èƒ½éè¿ç»­
    auto c = a.slice({{}, {}, {0, 4, 2}});  // æ¯éš”ä¸€åˆ—
    std::cout << c.isContiguous() << std::endl;  // false
    
    return 0;
}
```

#### éƒ¨åˆ†è¿ç»­æ€§æ£€æŸ¥

```cpp
auto a = YTensor<float, 3>::randn(2, 3, 4);
auto b = a.transpose(0, 1);  // å½¢çŠ¶ (3, 2, 4)

// b._stride = {4, 12, 1}
// b.stride() = {8, 4, 1}

std::cout << b.isContiguous(0) << std::endl;  // falseï¼ˆä»ç»´åº¦0å¼€å§‹ä¸è¿ç»­ï¼‰
std::cout << b.isContiguous(1) << std::endl;  // falseï¼ˆä»ç»´åº¦1å¼€å§‹ä¸è¿ç»­ï¼‰
std::cout << b.isContiguous(2) << std::endl;  // trueï¼ˆç»´åº¦2æœ¬èº«è¿ç»­ï¼‰
```

#### ä¼˜åŒ–ç®—æ³•é€‰æ‹©

```cpp
template <typename T, int dim>
void process(const YTensor<T, dim>& tensor) {
    if (tensor.isContiguous()) {
        // âœ… ä½¿ç”¨å¿«é€Ÿè·¯å¾„ï¼ˆSIMDã€memcpyï¼‰
        const T* data = tensor.data_();
        for (size_t i = 0; i < tensor.size(); i++) {
            // ç›´æ¥é¡ºåºè®¿é—®
            process_element(data[i]);
        }
    } else {
        // âŒ ä½¿ç”¨æ…¢é€Ÿè·¯å¾„ï¼ˆat() è®¿é—®ï¼‰
        for (size_t i = 0; i < tensor.size(); i++) {
            auto coord = tensor.toCoord(i);
            process_element(tensor.at(coord));
        }
    }
}
```

---

## isContiguousFrom()

### å‡½æ•°ç­¾å

```cpp
int isContiguousFrom() const;
```

### æ ¸å¿ƒåŠŸèƒ½æè¿°

è·å–å¼ é‡ä»å“ªä¸ªç»´åº¦å¼€å§‹æ˜¯è¿ç»­çš„ã€‚
è¿”å›ç¬¬ä¸€ä¸ª"ä»è¯¥ç»´åº¦å¼€å§‹å…¨éƒ¨è¿ç»­"çš„ç»´åº¦ç´¢å¼•ã€‚

### è¿”å›å€¼

- è¿”å›ä»è¯¥ç»´åº¦å¼€å§‹**å…¨éƒ¨è¿ç»­**çš„ç»´åº¦ç´¢å¼•
- å¦‚æœå®Œå…¨ä¸è¿ç»­ï¼Œè¿”å› `ndim()`
- å¦‚æœå…¨éƒ¨è¿ç»­ï¼Œè¿”å› `0`

### åˆ¤æ–­ç®—æ³•

```cpp
auto logStride = this->stride();
for (int a = ndim() - 1; a >= 0; --a) {
    if (logStride[a] != _stride[a] && _shape[a] > 1) {
        return a + 1;  // ä» a+1 ç»´åº¦å¼€å§‹è¿ç»­
    }
}
return 0;  // å…¨éƒ¨è¿ç»­
```

**ä»åå‘å‰**æ£€æŸ¥ï¼Œæ‰¾åˆ°**ç¬¬ä¸€ä¸ªä¸è¿ç»­çš„ç»´åº¦**ã€‚

### ä½¿ç”¨ç¤ºä¾‹

#### åŸºæœ¬ç”¨æ³•

```cpp
auto a = YTensor<float, 3>::randn(2, 3, 4);

// å…¨éƒ¨è¿ç»­
std::cout << a.isContiguousFrom() << std::endl;  // 0

// è½¬ç½® (0, 1)ï¼šåªæœ‰æœ€åä¸€ç»´è¿ç»­
auto b = a.transpose(0, 1);
std::cout << b.isContiguousFrom() << std::endl;  // 2

// åˆ‡ç‰‡æœ€åä¸€ç»´ï¼šå®Œå…¨ä¸è¿ç»­
auto c = a.slice({{}, {}, {0, 4, 2}});
std::cout << c.isContiguousFrom() << std::endl;  // 3
```

#### ä¸ isContiguous() çš„å…³ç³»

```cpp
auto a = YTensor<float, 3>::randn(2, 3, 4);
auto b = a.transpose(0, 1);

int from = b.isContiguousFrom();  // 2

// ç­‰ä»·å…³ç³»
assert(b.isContiguous(from) == true);  // ä» from å¼€å§‹è¿ç»­
if (from > 0) {
    assert(b.isContiguous(from - 1) == false);  // ä» from-1 å¼€å§‹ä¸è¿ç»­
}
```

#### ä¼˜åŒ–å†…å­˜æ‹·è´

```cpp
template <typename T, int dim>
void copy_tensor(const YTensor<T, dim>& src, YTensor<T, dim>& dst) {
    int from = src.isContiguousFrom();
    
    if (from == 0) {
        // âœ… å…¨éƒ¨è¿ç»­ï¼šå•æ¬¡ memcpy
        memcpy(dst.data_(), src.data_(), src.size() * sizeof(T));
    } else if (from < dim) {
        // ğŸ”¶ éƒ¨åˆ†è¿ç»­ï¼šæŒ‰è¿ç»­å—æ‹·è´
        size_t block_size = 1;
        for (int i = from; i < dim; i++) {
            block_size *= src.shape(i);
        }
        // æŒ‰ block_size å¤§å°åˆ†å—æ‹·è´...
    } else {
        // âŒ å®Œå…¨ä¸è¿ç»­ï¼šé€å…ƒç´ æ‹·è´
        for (size_t i = 0; i < src.size(); i++) {
            auto coord = src.toCoord(i);
            dst.at(coord) = src.at(coord);
        }
    }
}
```

---

## isDisjoint()

### å‡½æ•°ç­¾å

```cpp
bool isDisjoint() const;
```

### æ ¸å¿ƒåŠŸèƒ½æè¿°

æ£€æŸ¥å¼ é‡çš„å…ƒç´ åœ¨å†…å­˜ä¸­æ˜¯å¦**ä¸é‡å **ã€‚
å¦‚æœæ­¥å¹…å°äºç»´åº¦çš„æœ€å°è·¨åº¦ï¼Œåˆ™è®¤ä¸ºå¯èƒ½é‡å ã€‚
å¹¿æ’­åçš„å¼ é‡é€šå¸¸æ˜¯é‡å çš„ã€‚

### è¿”å›å€¼

- **true**ï¼šæ‰€æœ‰å…ƒç´ åœ¨å†…å­˜ä¸­å æ®ä¸åŒä½ç½®ï¼ˆä¸é‡å ï¼‰
- **false**ï¼šå­˜åœ¨å…ƒç´ å…±äº«ç›¸åŒå†…å­˜ä½ç½®ï¼ˆé‡å ï¼‰

### åˆ¤æ–­ç®—æ³•

```cpp
// è®¡ç®—æ¯ä¸ªç»´åº¦çš„æœ€å°è·¨åº¦ï¼ˆspan_lowerï¼‰
std::vector<int> span_lower(dim, 1);
for (int d = dim - 2; d >= 0; --d) {
    span_lower[d] = span_lower[d + 1] * _shape[d + 1];
}

// æ£€æŸ¥æ¯ä¸ªç»´åº¦
for (int d = 0; d < dim; ++d) {
    if (_shape[d] <= 1) continue;
    int abs_stride = std::abs(_stride[d]);
    if (abs_stride < span_lower[d]) {
        return false;  // é‡å 
    }
}
return true;  // ä¸é‡å 
```

**æ ¸å¿ƒæ€æƒ³**ï¼šå¦‚æœæŸç»´åº¦çš„æ­¥å¹… < ç†è®ºæœ€å°è·¨åº¦ï¼Œå¿…ç„¶é‡å ã€‚

### ä½¿ç”¨ç¤ºä¾‹

#### åŸºæœ¬ç”¨æ³•

```cpp
auto a = YTensor<float, 2>::randn(3, 4);

// æ­£å¸¸å¼ é‡ï¼šä¸é‡å 
std::cout << a.isDisjoint() << std::endl;  // true

// å¹¿æ’­å¼ é‡ï¼šé‡å 
auto b = a.slice({{}, {0, 1}});  // å–ç¬¬ä¸€åˆ— (3, 1)
auto c = b.expand(std::vector<int>{3, 4});  // å¹¿æ’­åˆ° (3, 4)
// c._stride = {4, 0}  â† æ­¥å¹…ä¸º 0ï¼Œæ‰€æœ‰åˆ—å…±äº«åŒä¸€å†…å­˜
std::cout << c.isDisjoint() << std::endl;  // false
```

#### æ£€æµ‹ stride=0 çš„å¹¿æ’­

```cpp
auto a = YTensor<float, 1>::randn(10);
auto b = a.reshape({10, 1});  // (10, 1)
auto c = b.expand(std::vector<int>{10, 5});  // å¹¿æ’­åˆ° (10, 5)

// c._shape = {10, 5}
// c._stride = {1, 0}  â† ç»´åº¦1æ­¥å¹…ä¸º0

std::cout << c.isDisjoint() << std::endl;  // false

// ä¸èƒ½å®‰å…¨åœ°ä¿®æ”¹ cï¼Œä¼šå½±å“å…¶ä»–åˆ—
// c.at(0, 0) = 1.0f;
// c.at(0, 1) == 1.0f  â† æ„å¤–ä¿®æ”¹
```

#### å®‰å…¨æ€§æ£€æŸ¥

```cpp
template <typename T, int dim>
void inplace_modify(YTensor<T, dim>& tensor) {
    if (!tensor.isDisjoint()) {
        throw std::runtime_error(
            "Cannot modify non-disjoint tensor inplace! "
            "Elements share memory and will affect each other."
        );
    }
    
    // å®‰å…¨åœ°ä¿®æ”¹
    for (auto& val : tensor) {
        val *= 2.0f;
    }
}
```

---

## shapeMatch()

### å‡½æ•°ç­¾å

```cpp
bool shapeMatch(const std::vector<int>& otherShape) const;
```

### å‚æ•°è¯´æ˜

| å‚æ•°å | ç±»å‹ | è¯´æ˜ |
|--------|------|------|
| `otherShape` | `const std::vector<int>&` | å¾…æ¯”è¾ƒçš„å½¢çŠ¶ |

### æ ¸å¿ƒåŠŸèƒ½æè¿°

æ£€æŸ¥å¼ é‡çš„å½¢çŠ¶æ˜¯å¦ä¸ç»™å®šå½¢çŠ¶åŒ¹é…ã€‚
ä»…æ¯”è¾ƒç»´åº¦æ•°é‡å’Œæ¯ä¸ªç»´åº¦çš„å¤§å°ï¼Œä¸æ¯”è¾ƒæ•°æ®ç±»å‹æˆ–æ­¥å¹…ã€‚

### è¿”å›å€¼

- **true**ï¼šç»´åº¦æ•°é‡ç›¸åŒï¼Œä¸”æ¯ä¸ªç»´åº¦å¤§å°ç›¸åŒ
- **false**ï¼šç»´åº¦æ•°é‡æˆ–å¤§å°ä¸åŒ¹é…

### åˆ¤æ–­ç®—æ³•

```cpp
if (otherShape.size() != ndim()) return false;
for (int i = 0; i < ndim(); ++i) {
    if (_shape[i] != otherShape[i]) return false;
}
return true;
```

### ä½¿ç”¨ç¤ºä¾‹

#### åŸºæœ¬ç”¨æ³•

```cpp
auto a = YTensor<float, 3>::randn(2, 3, 4);

// åŒ¹é…çš„å½¢çŠ¶
std::cout << a.shapeMatch({2, 3, 4}) << std::endl;  // true

// ä¸åŒ¹é…çš„å½¢çŠ¶
std::cout << a.shapeMatch({2, 3}) << std::endl;     // falseï¼ˆç»´åº¦ä¸åŒï¼‰
std::cout << a.shapeMatch({2, 3, 5}) << std::endl;  // falseï¼ˆå¤§å°ä¸åŒï¼‰
std::cout << a.shapeMatch({4, 3, 2}) << std::endl;  // falseï¼ˆé¡ºåºä¸åŒï¼‰
```

#### å¹¿æ’­å‰éªŒè¯

```cpp
template <typename T, int dim>
YTensor<T, dim> add_inplace(YTensor<T, dim>& a, const YTensor<T, dim>& b) {
    if (!a.shapeMatch(b.shape())) {
        throw std::invalid_argument(
            "Shape mismatch! Cannot add tensors with different shapes."
        );
    }
    
    for (size_t i = 0; i < a.size(); i++) {
        a.atData_(i) += b.atData_(i);
    }
    
    return a;
}
```

#### ä¸å…¶ä»–å¼ é‡æ¯”è¾ƒ

```cpp
auto a = YTensor<float, 3>::randn(2, 3, 4);
auto b = YTensor<float, 3>::randn(2, 3, 4);
auto c = a.transpose(0, 1);  // å½¢çŠ¶ (3, 2, 4)

std::cout << a.shapeMatch(b.shape()) << std::endl;  // true
std::cout << a.shapeMatch(c.shape()) << std::endl;  // false
```

---

## å±æ€§ç»„åˆä½¿ç”¨

### é€‰æ‹©æœ€ä½³ç®—æ³•

```cpp
template <typename T, int dim>
void element_wise_op(YTensor<T, dim>& a, const YTensor<T, dim>& b) {
    if (!a.shapeMatch(b.shape())) {
        throw std::invalid_argument("Shape mismatch");
    }
    
    if (a.isContiguous() && b.isContiguous()) {
        // âœ… æœ€å¿«ï¼šä¸¤è€…éƒ½è¿ç»­ï¼Œä½¿ç”¨ SIMD
        T* a_data = a.data_();
        const T* b_data = b.data_();
        #pragma omp simd
        for (size_t i = 0; i < a.size(); i++) {
            a_data[i] += b_data[i];
        }
    } else if (a.isDisjoint() && b.isDisjoint()) {
        // ğŸ”¶ ä¸­ç­‰ï¼šä¸è¿ç»­ä½†ä¸é‡å ï¼Œä½¿ç”¨ at()
        for (size_t i = 0; i < a.size(); i++) {
            auto coord = a.toCoord(i);
            a.at(coord) += b.at(coord);
        }
    } else {
        // âŒ æœ€æ…¢ï¼šå­˜åœ¨é‡å ï¼Œéœ€è¦ä¸´æ—¶ç¼“å†²
        auto tmp = a.clone();
        for (size_t i = 0; i < a.size(); i++) {
            auto coord = a.toCoord(i);
            tmp.at(coord) = a.at(coord) + b.at(coord);
        }
        a = std::move(tmp);
    }
}
```

### è°ƒè¯•å†…å­˜å¸ƒå±€

```cpp
template <typename T, int dim>
void print_memory_info(const YTensor<T, dim>& tensor) {
    std::cout << "å½¢çŠ¶: ";
    for (int i = 0; i < dim; i++) {
        std::cout << tensor.shape(i) << " ";
    }
    std::cout << std::endl;
    
    std::cout << "è¿ç»­æ€§: " 
              << (tensor.isContiguous() ? "å®Œå…¨è¿ç»­" : "éè¿ç»­") 
              << std::endl;
    
    int from = tensor.isContiguousFrom();
    if (from < dim) {
        std::cout << "ä»ç»´åº¦ " << from << " å¼€å§‹è¿ç»­" << std::endl;
    }
    
    std::cout << "å…ƒç´ é‡å : " 
              << (tensor.isDisjoint() ? "æ— é‡å " : "æœ‰é‡å ") 
              << std::endl;
    
    std::cout << "é€»è¾‘æ­¥å¹…: ";
    auto logStride = tensor.stride();
    for (auto s : logStride) {
        std::cout << s << " ";
    }
    std::cout << std::endl;
    
    std::cout << "ç‰©ç†æ­¥å¹…: ";
    for (int i = 0; i < dim; i++) {
        std::cout << tensor.stride_(i) << " ";
    }
    std::cout << std::endl;
}
```

---

## å¸¸è§æ¨¡å¼

### è¿ç»­æ€§æ¨¡å¼

| æ“ä½œ | isContiguous() | isContiguousFrom() | isDisjoint() |
|------|----------------|-------------------|--------------|
| `YTensor(2, 3, 4)` | âœ… true | 0 | âœ… true |
| `transpose(0, 1)` | âŒ false | 2 | âœ… true |
| `slice({}, {}, {0, 4, 2})` | âŒ false | 3 | âœ… true |
| `reshape({6, 4})` | âœ… true (if contiguous) | 0 | âœ… true |
| `expand({2, 3, 4})` | âŒ false | varies | âŒ false |

### ç‰¹æ®Šæƒ…å†µ

#### å¤§å°ä¸º 1 çš„ç»´åº¦

```cpp
auto a = YTensor<float, 3>::randn(1, 3, 4);

// å¤§å°ä¸º1çš„ç»´åº¦ä¸å½±å“è¿ç»­æ€§
std::cout << a.isContiguous() << std::endl;  // true

auto b = a.transpose(0, 1);  // (3, 1, 4)
std::cout << b.isContiguous() << std::endl;  // trueï¼ˆç»´åº¦1å¤§å°ä¸º1ï¼‰
```

#### æ ‡é‡å’Œä¸€ç»´å¼ é‡

```cpp
auto a = YTensor<float, 1>::randn(100);

// ä¸€ç»´å¼ é‡æ€»æ˜¯è¿ç»­çš„
std::cout << a.isContiguous() << std::endl;       // true
std::cout << a.isContiguousFrom() << std::endl;  // 0
std::cout << a.isDisjoint() << std::endl;        // true
```

#### ç©ºå¼ é‡

```cpp
auto a = YTensor<float, 2>();  // æœªåˆå§‹åŒ–

// ç©ºå¼ é‡è¢«è§†ä¸ºä¸è¿ç»­
std::cout << a.isContiguous() << std::endl;       // false
std::cout << a.isContiguousFrom() << std::endl;  // dim
std::cout << a.isDisjoint() << std::endl;        // false
```

---

## æ€§èƒ½å½±å“

### åŸºå‡†æµ‹è¯•

åŸºäº (1000, 1000) å¼ é‡çš„å…ƒç´ è®¿é—®ï¼ˆ10M æ¬¡æ“ä½œï¼‰ï¼š

| å¼ é‡ç±»å‹ | è®¿é—®æ–¹å¼ | æ—¶é—´ (ms) | ç›¸å¯¹é€Ÿåº¦ |
|---------|---------|----------|---------|
| è¿ç»­ | ç›´æ¥æŒ‡é’ˆ | 15 | 10.0x |
| è¿ç»­ | `atData_()` | 18 | 8.3x |
| è¿ç»­ | `at()` | 45 | 3.3x |
| éè¿ç»­ | `at()` | 150 | 1.0x |
| éè¿ç»­ | `atData_()` | 22 | 6.8x âš ï¸ |

âš ï¸ æ³¨æ„ï¼šéè¿ç»­å¼ é‡ä½¿ç”¨ `atData_()` ä¼šå¾—åˆ°é”™è¯¯ç»“æœï¼

### ä¼˜åŒ–å»ºè®®

```cpp
// âŒ ä½æ•ˆï¼šå¿½ç•¥è¿ç»­æ€§
for (size_t i = 0; i < tensor.size(); i++) {
    auto coord = tensor.toCoord(i);
    process(tensor.at(coord));  // æ€»æ˜¯ä½¿ç”¨ at()
}

// âœ… é«˜æ•ˆï¼šæ ¹æ®è¿ç»­æ€§é€‰æ‹©ç®—æ³•
if (tensor.isContiguous()) {
    T* data = tensor.data_();
    for (size_t i = 0; i < tensor.size(); i++) {
        process(data[i]);  // å¿«é€Ÿè·¯å¾„
    }
} else {
    for (size_t i = 0; i < tensor.size(); i++) {
        auto coord = tensor.toCoord(i);
        process(tensor.at(coord));  // æ…¢é€Ÿè·¯å¾„
    }
}
```

---

## æ³¨æ„äº‹é¡¹

:::warning
**isContiguous() çš„é™åˆ¶**

`isContiguous()` åªæ£€æŸ¥**æ­¥å¹…ä¸€è‡´æ€§**ï¼Œä¸ä¿è¯å…ƒç´ **ä¸é‡å **ï¼š

```cpp
auto a = YTensor<float, 2>::randn(4, 5);
auto b = a.slice({{0, 4, 2}, {}});  // æ¯éš”ä¸€è¡Œ (2, 5)

std::cout << b.isContiguous() << std::endl;  // false
std::cout << b.isDisjoint() << std::endl;    // true

// è™½ç„¶ä¸è¿ç»­ï¼Œä½†å…ƒç´ ä¸é‡å ï¼Œå¯ä»¥å®‰å…¨ä¿®æ”¹
```

**åŒºåˆ«**ï¼š
- `isContiguous()` â†’ èƒ½å¦ä½¿ç”¨ SIMD
- `isDisjoint()` â†’ èƒ½å¦å®‰å…¨ä¿®æ”¹
:::

:::warning
**isDisjoint() ä¸å¹¿æ’­**

å¹¿æ’­åçš„å¼ é‡**æ€»æ˜¯éä¸é‡å çš„**ï¼š

```cpp
auto a = YTensor<float, 2>::randn(3, 1);
auto b = a.expand({3, 5});  // å¹¿æ’­

std::cout << b.isDisjoint() << std::endl;  // false

// âŒ å±é™©ï¼šä¿®æ”¹ä¼šå½±å“æ‰€æœ‰åˆ—
b.at(0, 0) = 1.0f;
// b.at(0, 1), b.at(0, 2), ... å…¨éƒ¨å˜ä¸º 1.0f
```
:::

:::info
**shapeMatch() ä»…æ£€æŸ¥å½¢çŠ¶**

`shapeMatch()` ä¸æ£€æŸ¥æ•°æ®ç±»å‹æˆ–æ­¥å¹…ï¼š

```cpp
auto a = YTensor<float, 2>::randn(3, 4);
auto b = YTensor<double, 2>::randn(3, 4);

// å½¢çŠ¶åŒ¹é…ï¼Œä½†ç±»å‹ä¸åŒ
// a.shapeMatch(b.shape()) == true
```
:::

---

## æœ€ä½³å®è·µ

### 1. æ€§èƒ½å…³é”®è·¯å¾„ï¼šä¼˜å…ˆæ£€æŸ¥è¿ç»­æ€§

```cpp
// âœ… é«˜æ•ˆ
if (tensor.isContiguous()) {
    fast_path(tensor.data_(), tensor.size());
} else {
    slow_path(tensor);
}
```

### 2. åŸåœ°ä¿®æ”¹ï¼šæ£€æŸ¥é‡å 

```cpp
// âœ… å®‰å…¨
if (!tensor.isDisjoint()) {
    throw std::runtime_error("Cannot modify overlapping tensor inplace");
}
modify_inplace(tensor);
```

### 3. å½¢çŠ¶éªŒè¯ï¼šä½¿ç”¨ shapeMatch

```cpp
// âœ… æ¸…æ™°
if (!a.shapeMatch(b.shape())) {
    throw std::invalid_argument("Shape mismatch");
}
```

### 4. è°ƒè¯•ï¼šç»„åˆä½¿ç”¨

```cpp
// âœ… å…¨é¢
void validate_tensor(const auto& tensor) {
    std::cout << "è¿ç»­: " << tensor.isContiguous() << std::endl;
    std::cout << "ä¸é‡å : " << tensor.isDisjoint() << std::endl;
    std::cout << "è¿ç»­èµ·å§‹ç»´åº¦: " << tensor.isContiguousFrom() << std::endl;
}
```

---

## ç›¸å…³å†…å®¹

- [æ­¥å¹…æŸ¥è¯¢](../shape/query.mdx) - stride() å’Œ stride_()
- [å†…å­˜æ“ä½œ](../construction/memory.mdx) - contiguous() å’Œ clone()
- [å¹¿æ’­æ“ä½œ](../math/broadcast.mdx) - expand() å’Œå¹¿æ’­è§„åˆ™
- [ç´¢å¼•è®¿é—®](../access/indexing.mdx) - at() å’Œ atData()
