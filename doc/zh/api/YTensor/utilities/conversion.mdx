# 坐标转换

本文档介绍 YTensor 的坐标转换工具：在多维坐标和一维索引之间转换。

---

## 概述

YTensor 提供三个坐标转换方法：

- **toIndex()** - 多维坐标 → 逻辑索引（考虑步幅）
- **toIndex_()** - 多维坐标 → 物理偏移（直接计算）
- **toCoord()** - 逻辑索引 → 多维坐标

这些方法用于：
- 实现自定义访问模式
- 调试内存布局
- 与 `atData()` / `atData_()` 配合使用

---

## toIndex()

### 函数签名

```cpp
// 变长参数版本
template <typename... Args>
size_t toIndex(Args... args) const;

// 向量版本
size_t toIndex(const std::vector<int>& pos) const;
```

### 参数说明

| 参数名 | 类型 | 说明 |
|--------|------|------|
| `args` | 可变参数 | dim 个整数坐标（必须恰好 dim 个）|
| `pos` | `std::vector<int>` | 长度为 dim 的坐标向量 |

### 核心功能描述

将多维坐标转换为**逻辑索引**。
计算公式：`index = pos[0] * stride()[0] + ... + pos[dim-1] * stride()[dim-1]`
其中 `stride()` 是**逻辑步幅**（经过重新计算）。


### 返回值

返回 `size_t` 类型的**逻辑索引**。

### 使用示例

#### 基本用法

```cpp
#include "ytensor_single.hpp"

int main() {
    using namespace yt;
    
    auto a = YTensor<float, 3>({2, 3, 4});
    
    // 变长参数版本
    size_t idx1 = a.toIndex(1, 2, 3);
    // 计算: 1*12 + 2*4 + 3*1 = 23
    
    // 向量版本
    std::vector<int> pos = {1, 2, 3};
    size_t idx2 = a.toIndex(pos);  // 23
    
    return 0;
}
```

#### 与 atData() 配合

```cpp
auto a = YTensor<float, 3>::randn(2, 3, 4);

// 方法1：直接访问
float val1 = a.at(1, 2, 3);

// 方法2：toIndex + atData
size_t idx = a.toIndex(1, 2, 3);
float val2 = a.atData(idx);

// val1 == val2 ✅
```

---

## toIndex_()

### 函数签名

```cpp
// 变长参数版本
template <typename... Args>
size_t toIndex_(Args... args) const;

// 向量版本
size_t toIndex_(const std::vector<int>& pos) const;
```

### 参数说明

| 参数名 | 类型 | 说明 |
|--------|------|------|
| `args` | 可变参数 | dim 个整数坐标 |
| `pos` | `std::vector<int>` | 长度为 dim 的坐标向量 |

### 核心功能描述

将多维坐标转换为**物理偏移**（相对于 `data_()` 指针）。
计算公式：`offset = pos[0] * _stride[0] + ... + pos[dim-1] * _stride[dim-1]`
其中 `_stride` 是**物理步幅**（内部存储的实际值）。


### 返回值

返回 `size_t` 类型的**物理偏移**。

### 使用示例

#### 与 atData_() 配合

```cpp
auto a = YTensor<float, 3>::randn(2, 3, 4);

// 方法1：使用 at()
float val1 = a.at(1, 2, 3);

// 方法2：toIndex_ + atData_
size_t offset = a.toIndex_(1, 2, 3);
float val2 = a.atData_(offset);

// val1 == val2 ✅
```

#### 访问原始内存

```cpp
auto a = YTensor<float, 3>::randn(2, 3, 4);

size_t offset = a.toIndex_(1, 2, 3);
float* ptr = a.data_() + offset;  // 直接指针运算
float val = *ptr;
```

---

## toCoord()

### 函数签名

```cpp
std::vector<int> toCoord(size_t index) const;
```

### 参数说明

| 参数名 | 类型 | 说明 |
|--------|------|------|
| `index` | `size_t` | 逻辑索引（0 到 size()-1）|

### 核心功能描述

将**逻辑索引**转换为多维坐标。
使用除法和取模算法，从最后一维开始逆向计算。

### 返回值

返回 `std::vector<int>` 类型的坐标向量，长度为 `dim`。

### 算法

使用**除法和取模**计算坐标：

```cpp
std::vector<int> pos(dim);
for (int i = dim - 1; i >= 0; --i) {
    pos[i] = index % _shape[i];
    index /= _shape[i];
}
```

从**最后一维**开始向前计算。

### 使用示例

#### 基本用法

```cpp
auto a = YTensor<float, 3>({2, 3, 4});

// 索引 23 对应的坐标
auto coord = a.toCoord(23);
// coord = {1, 2, 3}

// 验证：逆向转换
size_t idx = a.toIndex(coord);  // 23
```

#### 遍历张量

```cpp
auto a = YTensor<float, 3>::randn(2, 3, 4);

// 使用逻辑索引遍历
for (size_t i = 0; i < a.size(); i++) {
    auto coord = a.toCoord(i);
    float val = a.at(coord);
    
    std::cout << "pos[" << coord[0] << "," << coord[1] << "," << coord[2] 
              << "] = " << val << std::endl;
}
```

---

## toIndex() vs toIndex_()

### 核心区别

| 特性 | toIndex() | toIndex_() |
|------|-----------|------------|
| 步幅类型 | **逻辑步幅** `stride()` | **物理步幅** `_stride` |
| 计算方式 | 重新计算步幅 | 直接使用内部步幅 |
| 用途 | 配合 `atData()` | 配合 `atData_()` |
| 性能 | 稍慢（需计算步幅）| 更快（直接访问）|

### 行为差异

:::warning
**关键区别**

对于**非连续张量**，两者返回值**不同**！

```cpp
auto a = YTensor<float, 2>({3, 4});
auto b = a.slice({{0, 2}, {0, 4, 2}});  // 非连续：每隔一列
// b.shape() = {2, 2}
// b._stride = {4, 2}  （物理步幅）
// b.stride() = {2, 1}  （逻辑步幅）

size_t idx_logical = b.toIndex(1, 1);   // 1*2 + 1*1 = 3
size_t idx_physical = b.toIndex_(1, 1);  // 1*4 + 1*2 = 6

// ❌ idx_logical != idx_physical

// ✅ 正确用法
float val1 = b.atData(idx_logical);   // 使用逻辑索引
float val2 = b.atData_(idx_physical); // 使用物理偏移
// val1 == val2 ✅
```
:::

### 选择指南

```cpp
// ✅ 推荐：使用 toIndex() + atData()
size_t idx = tensor.toIndex(i, j, k);
float val = tensor.atData(idx);

// ✅ 或使用 toIndex_() + atData_()
size_t offset = tensor.toIndex_(i, j, k);
float val = tensor.atData_(offset);

// ❌ 错误：混用
size_t idx = tensor.toIndex(i, j, k);
float val = tensor.atData_(idx);  // 对非连续张量错误！
```

---

## toCoord() 与 toIndex() 的可逆性

### 连续张量：完全可逆

```cpp
auto a = YTensor<float, 3>({2, 3, 4});

// 正向
auto coord = a.toCoord(23);  // {1, 2, 3}
size_t idx = a.toIndex(coord);  // 23 ✅
```

### 非连续张量：单向可逆

```cpp
auto a = YTensor<float, 2>({4, 5});
auto b = a.slice({{0, 4, 2}, {0, 5}});  // 每隔一行
// b.shape() = {2, 5}

// ✅ toCoord → toIndex 可逆
auto coord = b.toCoord(7);      // {1, 2}
size_t idx = b.toIndex(coord);  // 7 ✅

// ❌ toIndex_ → toCoord 不可逆
size_t offset = b.toIndex_(1, 2);  // 12 (物理偏移)
auto coord2 = b.toCoord(12);       // {2, 2} ❌ （超出范围）
```

:::info
**规则**

- `toCoord()` 的输入是**逻辑索引**（0 到 size()-1）
- `toIndex()` 返回**逻辑索引**，可以传给 `toCoord()`
- `toIndex_()` 返回**物理偏移**，**不能**传给 `toCoord()`
:::

---

## 错误处理

### 维度不匹配

```cpp
auto a = YTensor<float, 3>({2, 3, 4});

// ❌ 编译错误：参数数量不匹配
// size_t idx = a.toIndex(1, 2);  // static_assert 失败

// ❌ 运行时错误：向量长度不匹配
std::vector<int> pos = {1, 2};
// size_t idx = a.toIndex(pos);  
// 抛出: invalid_argument: "toIndex: position dimensions do not match ndim"
```

### 索引越界

```cpp
auto a = YTensor<float, 3>({2, 3, 4});

// toIndex/toIndex_ 不检查边界
size_t idx = a.toIndex(10, 20, 30);  // ⚠️ 不报错，但结果无意义

// atData 会检查边界
// float val = a.atData(idx);  // ❌ 抛出异常
```

### toCoord() 越界

```cpp
auto a = YTensor<float, 3>({2, 3, 4});

// toCoord 不检查边界
auto coord = a.toCoord(1000);  // ⚠️ 返回错误坐标
```

---

## 性能考虑

### 性能对比

基于 (1000, 1000) 张量的基准测试（1M 次调用）：

| 操作 | 时间 (ms) | 相对速度 |
|------|----------|---------|
| `at(i, j)` | 45 | 1.0x |
| `toIndex() + atData()` | 52 | 0.87x |
| `toIndex_() + atData_()` | 38 | 1.18x |
| `toCoord()` | 72 | 0.62x |

**结论**：
- `toIndex_() + atData_()` 最快（直接访问物理内存）
- `at()` 次之（内联优化）
- `toIndex() + atData()` 稍慢（需计算逻辑步幅）
- `toCoord()` 最慢（除法和取模）

### 优化建议

```cpp
// ❌ 低效：重复调用 toIndex
for (int i = 0; i < 100; i++) {
    for (int j = 0; j < 100; j++) {
        size_t idx = tensor.toIndex(i, j);  // 每次重新计算
        float val = tensor.atData(idx);
    }
}

// ✅ 高效：直接使用 at()
for (int i = 0; i < 100; i++) {
    for (int j = 0; j < 100; j++) {
        float val = tensor.at(i, j);  // 编译器内联优化
    }
}

// ✅ 或使用迭代器
for (auto& val : tensor) {
    // 最快的遍历方式
}
```

---

## 使用场景

### 1. 自定义访问模式

```cpp
auto a = YTensor<float, 3>::randn(10, 10, 10);

// 访问对角线元素 (i, i, i)
for (int i = 0; i < 10; i++) {
    size_t idx = a.toIndex(i, i, i);
    float val = a.atData(idx);
    std::cout << val << std::endl;
}
```

### 2. 调试内存布局

```cpp
auto a = YTensor<float, 2>({3, 4});
auto b = a.transpose(0, 1);

std::cout << "原始张量步幅: ";
for (int i = 0; i < 2; i++) {
    std::cout << a.stride()[i] << " ";
}
std::cout << std::endl;

std::cout << "转置后步幅: ";
for (int i = 0; i < 2; i++) {
    std::cout << b.stride()[i] << " ";
}
std::cout << std::endl;

// 检查内存布局
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 4; j++) {
        size_t offset = b.toIndex_(i, j);
        std::cout << "b[" << i << "," << j << "] 物理偏移: " << offset << std::endl;
    }
}
```

### 3. 与 C API 交互

```cpp
void process_tensor(float* data, const int* shape, int ndim) {
    auto a = YTensor<float, 3>(shape);
    memcpy(a.data_(), data, a.size() * sizeof(float));
    
    // 使用 toIndex_ 访问原始数据
    for (int i = 0; i < shape[0]; i++) {
        for (int j = 0; j < shape[1]; j++) {
            for (int k = 0; k < shape[2]; k++) {
                size_t offset = a.toIndex_(i, j, k);
                data[offset] *= 2.0f;  // 直接修改原始数据
            }
        }
    }
}
```

### 4. 稀疏访问

```cpp
auto a = YTensor<float, 3>::randn(100, 100, 100);

// 访问特定坐标列表
std::vector<std::vector<int>> coords = {
    {10, 20, 30},
    {15, 25, 35},
    {20, 30, 40}
};

for (const auto& coord : coords) {
    size_t idx = a.toIndex(coord);
    float val = a.atData(idx);
    // 处理 val
}
```

---

## 与其他方法的关系

### 与 at() 的关系

```cpp
// 等价操作
float val1 = tensor.at(i, j, k);

size_t idx = tensor.toIndex(i, j, k);
float val2 = tensor.atData(idx);

// val1 == val2 ✅
```

### 与 data_() 的关系

```cpp
// 等价操作
float val1 = tensor.at(i, j, k);

size_t offset = tensor.toIndex_(i, j, k);
float val2 = tensor.data_()[offset];

// val1 == val2 ✅
```

### 与迭代器的关系

```cpp
auto a = YTensor<float, 3>({2, 3, 4});

// 方法1：迭代器
int count = 0;
for (auto& val : a) {
    auto coord = a.toCoord(count++);
    // 使用 coord 和 val
}

// 方法2：索引
for (size_t i = 0; i < a.size(); i++) {
    auto coord = a.toCoord(i);
    float val = a.atData(i);
    // 使用 coord 和 val
}
```

---

## 注意事项

:::warning
**混用风险**

**绝对不要**混用逻辑索引和物理偏移！

```cpp
// ❌ 错误示例
auto a = YTensor<float, 2>({3, 4});
auto b = a.slice({{0, 3, 2}, {}});  // 非连续

size_t idx_logical = b.toIndex(1, 2);
float val = b.atData_(idx_logical);  // ❌ 结果错误！

size_t offset_physical = b.toIndex_(1, 2);
float val2 = b.atData(offset_physical);  // ❌ 结果错误！
```

**正确用法**：
- `toIndex()` ↔ `atData()`
- `toIndex_()` ↔ `atData_()`
:::

:::info
**边界检查**

坐标转换方法**不进行边界检查**：

```cpp
auto a = YTensor<float, 2>({3, 4});

size_t idx = a.toIndex(10, 20);  // ⚠️ 不报错
// float val = a.atData(idx);    // ❌ atData 会报错
```

如果需要安全访问，使用 `at()` 而不是 `toIndex() + atData()`。
:::

:::info
**toCoord() 的限制**

`toCoord()` 假设张量是**连续的**：

```cpp
auto a = YTensor<float, 2>({4, 5});
auto b = a.slice({{0, 4, 2}, {}});  // 非连续

// toCoord 假设步幅为 [5, 1]，但实际是 [10, 1]
auto coord = b.toCoord(7);  // 可能返回错误坐标
```

对于非连续张量，`toCoord()` 的结果可能**不正确**。
:::

---

## 最佳实践

### 1. 优先使用高层 API

```cpp
// ❌ 繁琐且易错
for (int i = 0; i < shape[0]; i++) {
    for (int j = 0; j < shape[1]; j++) {
        size_t idx = tensor.toIndex(i, j);
        float val = tensor.atData(idx);
        // ...
    }
}

// ✅ 简洁且高效
for (int i = 0; i < shape[0]; i++) {
    for (int j = 0; j < shape[1]; j++) {
        float val = tensor.at(i, j);  // 直接访问
        // ...
    }
}
```

### 2. 仅在必要时使用转换

坐标转换适用于：
- 自定义访问模式（对角线、稀疏）
- 调试内存布局
- 与 C API 交互
- 性能关键路径（使用 `toIndex_() + atData_()`）

普通访问请使用 `at()`。

### 3. 配对使用

```cpp
// ✅ 配对1
size_t idx = tensor.toIndex(i, j, k);
float val = tensor.atData(idx);

// ✅ 配对2
size_t offset = tensor.toIndex_(i, j, k);
float val = tensor.atData_(offset);

// ✅ 配对3
auto coord = tensor.toCoord(idx);
size_t idx2 = tensor.toIndex(coord);  // idx == idx2
```

---

## 相关内容

- [索引访问](../access/indexing.mdx) - at() 和 operator[]
- [指针访问](../access/data_ptr.mdx) - data() 和 data_()
- [步幅查询](../shape/query.mdx) - stride() 和 stride_()
- [迭代器](../access/iteration.mdx) - begin() 和 end()
