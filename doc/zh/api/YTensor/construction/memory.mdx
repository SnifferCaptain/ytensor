# 内存管理

本文档介绍 `YTensor<T, dim>` 类的内存管理相关方法，包括深拷贝、浅拷贝和内存分配。

## 概览

YTensor 提供了灵活的内存管理机制：

| 方法 | 类型 | 说明 |
| --- | --- | --- |
| `clone()` | 深拷贝 | 创建独立的数据副本 |
| `shallowCopyTo()` | 浅拷贝 | 共享数据到目标张量 |
| `shareTo()` | 浅拷贝 | `shallowCopyTo()` 的别名 |
| `shallowCopyFrom()` | 浅拷贝 | 从源张量共享数据 |
| `shareFrom()` | 浅拷贝 | `shallowCopyFrom()` 的别名 |
| `reserve()` | 重新分配 | 分配新的连续内存空间 |

---

## clone()

### 函数签名

```cpp
YTensor clone() const;
```

### 核心功能描述

创建当前张量的深拷贝，返回一个拥有独立数据的新张量。即使源张量是非连续的（通过切片、转置等操作得到），返回的张量也是连续的。

### 返回值

- **类型**: `YTensor<T, dim>`
- **说明**: 返回一个新的张量，拥有独立的内存空间
- **内存行为**: 深拷贝，不共享内存。修改返回的张量不会影响原张量

### 使用示例

```cpp
#include "ytensor_single.hpp"

void example() {
    // 创建原始张量
    yt::YTensor<float, 2> a(3, 4);
    a.fill(1.0f);
    
    // 深拷贝
    auto b = a.clone();
    
    // 修改 b 不影响 a
    b.at(0, 0) = 10.0f;
    std::cout << a.at(0, 0) << std::endl;  // 输出: 1.0
    std::cout << b.at(0, 0) << std::endl;  // 输出: 10.0
    
    // 对非连续张量进行深拷贝
    auto c = a.transpose();  // c 是非连续的
    std::cout << c.isContiguous() << std::endl;  // 输出: 0 (false)
    
    auto d = c.clone();  // d 是连续的
    std::cout << d.isContiguous() << std::endl;  // 输出: 1 (true)
}
```

### 实现细节

`clone()` 方法会：
1. 创建一个新的连续张量
2. 按照逻辑顺序复制所有元素（即使源张量非连续）
3. 返回的张量保证是连续的

### 性能考虑

- 深拷贝涉及内存分配和数据复制，对大型张量可能有较大开销
- 使用 SIMD 优化（`#pragma omp simd`）加速复制过程
- 对于非连续张量，需要通过索引计算访问源数据

---

## shallowCopyTo()

### 函数签名

```cpp
void shallowCopyTo(YTensor& other) const;
```

### 参数说明

| 参数名 | 类型 | 说明 |
| --- | --- | --- |
| `other` | `YTensor&` | 目标张量，将被设置为共享当前张量的数据 |

### 核心功能描述

将当前张量的数据共享给目标张量。目标张量将与当前张量共享相同的内存、形状、步长等所有属性。

### 返回值

- **类型**: `void`

### 使用示例

```cpp
#include "ytensor_single.hpp"

void example() {
    yt::YTensor<float, 2> a(3, 4);
    a.fill(1.0f);
    
    yt::YTensor<float, 2> b;
    
    // 浅拷贝：a 的数据共享给 b
    a.shallowCopyTo(b);
    
    // 验证形状
    std::cout << b.shape(0) << ", " << b.shape(1) << std::endl;  // 输出: 3, 4
    
    // 修改 b 会影响 a
    b.at(1, 2) = 5.0f;
    std::cout << a.at(1, 2) << std::endl;  // 输出: 5.0
}
```

### 注意事项

:::warning
**共享内存**

浅拷贝后，两个张量共享相同的底层数据。任何一个张量的修改都会影响另一个。
:::

---

## shareTo()

### 函数签名

```cpp
void shareTo(YTensor& other) const;
```

### 核心功能描述

`shallowCopyTo()` 的别名方法，功能完全相同。提供更直观的命名。

### 参数说明

| 参数名 | 类型 | 说明 |
| --- | --- | --- |
| `other` | `YTensor&` | 目标张量 |

### 返回值

- **类型**: `void`

### 使用示例

```cpp
#include "ytensor_single.hpp"

void example() {
    yt::YTensor<float, 2> a(3, 4);
    yt::YTensor<float, 2> b;
    
    // 与 shallowCopyTo 完全相同
    a.shareTo(b);
    
    // b 现在共享 a 的数据
}
```

---

## shallowCopyFrom()

### 函数签名

```cpp
YTensor& shallowCopyFrom(const YTensor& src);
```

### 参数说明

| 参数名 | 类型 | 说明 |
| --- | --- | --- |
| `src` | `const YTensor&` | 源张量 |

### 核心功能描述

从源张量浅拷贝数据到当前张量。当前张量将与源张量共享相同的内存。

### 返回值

- **类型**: `YTensor&`
- **说明**: 返回当前张量的引用，支持链式调用

### 使用示例

```cpp
#include "ytensor_single.hpp"

void example() {
    yt::YTensor<float, 2> a(3, 4);
    a.fill(2.0f);
    
    yt::YTensor<float, 2> b;
    
    // 从 a 浅拷贝到 b
    b.shallowCopyFrom(a);
    
    // 验证共享
    std::cout << b.at(0, 0) << std::endl;  // 输出: 2.0
    
    // 修改 b 影响 a
    b.at(0, 0) = 10.0f;
    std::cout << a.at(0, 0) << std::endl;  // 输出: 10.0
}
```

### 链式调用

```cpp
yt::YTensor<float, 2> a(3, 4);
yt::YTensor<float, 2> b;

b.shallowCopyFrom(a).fill(5.0f);  // 链式调用
```

---

## shareFrom()

### 函数签名

```cpp
YTensor& shareFrom(const YTensor& src);
```

### 核心功能描述

`shallowCopyFrom()` 的别名方法，功能完全相同。

### 参数说明

| 参数名 | 类型 | 说明 |
| --- | --- | --- |
| `src` | `const YTensor&` | 源张量 |

### 返回值

- **类型**: `YTensor&`
- **说明**: 返回当前张量的引用

### 使用示例

```cpp
#include "ytensor_single.hpp"

void example() {
    yt::YTensor<float, 2> a(3, 4);
    yt::YTensor<float, 2> b;
    
    // 与 shallowCopyFrom 完全相同
    b.shareFrom(a);
}
```

---

## reserve()

### 函数签名

```cpp
// vector 版本
YTensor& reserve(const std::vector<int>& shape);

// 可变参数版本
template<typename... Args>
YTensor& reserve(Args... args);
```

### 参数说明

| 参数名 | 类型 | 说明 |
| --- | --- | --- |
| `shape` | `const std::vector<int>&` | 新的张量形状 |
| `args` | `Args...` | 可变参数，每个参数表示一个维度的大小 |

### 核心功能描述

重新分配连续内存空间并设置新的形状。**原有的数据将被丢弃**，行为类似于重新构造张量。

### 返回值

- **类型**: `YTensor&`
- **说明**: 返回当前张量的引用，支持链式调用

### 使用示例

```cpp
#include "ytensor_single.hpp"

void example() {
    // 方法1：先创建空张量，再 reserve
    yt::YTensor<float, 3> a;
    a.reserve(2, 3, 4);
    std::cout << a.size() << std::endl;  // 输出: 24
    
    // 方法2：重新分配已有张量
    yt::YTensor<float, 3> b(5, 5, 5);
    b.fill(1.0f);
    
    b.reserve(2, 3, 4);  // 旧数据丢失
    std::cout << b.size() << std::endl;  // 输出: 24
    
    // 方法3：使用 vector
    std::vector<int> shape = {3, 4, 5};
    yt::YTensor<float, 3> c;
    c.reserve(shape);
    
    // 方法4：链式调用
    auto d = yt::YTensor<float, 2>().reserve(10, 20).fill(0.5f);
}
```

### 异常

- 如果参数个数与 `dim` 不匹配，抛出 `std::invalid_argument` 异常（vector版本）
- 可变参数版本在编译时检查参数个数

### 注意事项

:::danger
**数据丢失**

`reserve()` 会**丢弃**原有的数据！它不是扩容操作，而是完全重新分配内存。

如果需要保留数据，请使用其他方法（如 `clone()` 后 `reshape()`）。
:::

:::info
**连续性保证**

`reserve()` 分配的内存总是连续的，这与构造函数的行为一致。
:::

### 与构造函数的关系

```cpp
// 这两种方式等价
yt::YTensor<float, 2> a(3, 4);

yt::YTensor<float, 2> b;
b.reserve(3, 4);
```

---

## 浅拷贝 vs 深拷贝对比

| 操作 | 方法 | 内存共享 | 性能 | 用途 |
| --- | --- | --- | --- | --- |
| 深拷贝 | `clone()` | 否 | 慢 | 需要独立副本 |
| 浅拷贝 | `shallowCopyTo()`<br/>`shareTo()` | 是 | 快 | 传递张量引用 |
| 浅拷贝 | `shallowCopyFrom()`<br/>`shareFrom()` | 是 | 快 | 接收张量引用 |
| 构造/赋值 | `YTensor(other)`<br/>`operator=` | 是 | 快 | 默认行为 |

---

## 完整示例

```cpp
#include <iostream>
#include "ytensor_single.hpp"

int main() {
    // 1. 创建原始张量
    yt::YTensor<float, 2> original(3, 4);
    original.fill(1.0f);
    original.at(0, 0) = 99.0f;
    
    std::cout << "=== 深拷贝 ===" << std::endl;
    // 2. 深拷贝
    auto deep = original.clone();
    deep.at(1, 1) = 10.0f;
    
    std::cout << "Original[0,0]: " << original.at(0, 0) << std::endl;  // 99.0
    std::cout << "Original[1,1]: " << original.at(1, 1) << std::endl;  // 1.0
    std::cout << "Deep[1,1]: " << deep.at(1, 1) << std::endl;          // 10.0
    
    std::cout << "\n=== 浅拷贝 ===" << std::endl;
    // 3. 浅拷贝
    yt::YTensor<float, 2> shallow;
    original.shallowCopyTo(shallow);
    shallow.at(2, 2) = 20.0f;
    
    std::cout << "Original[2,2]: " << original.at(2, 2) << std::endl;  // 20.0
    std::cout << "Shallow[2,2]: " << shallow.at(2, 2) << std::endl;    // 20.0
    
    std::cout << "\n=== reserve ===" << std::endl;
    // 4. reserve
    yt::YTensor<float, 2> tensor;
    tensor.reserve(2, 3).fill(5.0f);
    
    std::cout << "Tensor size: " << tensor.size() << std::endl;        // 6
    std::cout << "Tensor[0,0]: " << tensor.at(0, 0) << std::endl;      // 5.0
    
    // 5. 验证非连续张量的 clone
    std::cout << "\n=== 非连续张量克隆 ===" << std::endl;
    auto sliced = original.slice(0, 0, 2);  // 非连续
    std::cout << "Sliced contiguous: " << sliced.isContiguous() << std::endl;  // 0
    
    auto cloned_sliced = sliced.clone();
    std::cout << "Cloned contiguous: " << cloned_sliced.isContiguous() << std::endl;  // 1
    
    return 0;
}
```

---

## 内存管理最佳实践

### 何时使用深拷贝

```cpp
// ✅ 需要独立副本时
auto backup = tensor.clone();

// ✅ 需要保存非连续张量为连续版本时
auto continuous = non_continuous_tensor.clone();

// ✅ 需要在函数外部保留数据时
YTensor<float, 2> getData() {
    YTensor<float, 2> temp(3, 4);
    // ... 填充数据 ...
    return temp.clone();  // 返回独立副本
}
```

### 何时使用浅拷贝

```cpp
// ✅ 函数参数传递（避免不必要的拷贝）
void process(const YTensor<float, 2>& tensor) {
    YTensor<float, 2> local;
    local.shareFrom(tensor);  // 共享数据，避免拷贝
    // ... 处理 ...
}

// ✅ 创建别名
auto alias = tensor;  // 默认就是浅拷贝

// ✅ 视图操作（已经是浅拷贝）
auto view = tensor.slice(0, 1, 3);  // 返回视图
```

### 何时使用 reserve

```cpp
// ✅ 延迟初始化
YTensor<float, 2> tensor;
// ... 某些逻辑 ...
tensor.reserve(rows, cols);

// ✅ 重用张量对象（避免重复分配）
for (int i = 0; i < iterations; ++i) {
    tensor.reserve(sizes[i], sizes[i]);
    // ... 使用 tensor ...
}
```

---

## 相关内容

- [构造函数](./constructors.mdx) - 了解张量的创建方式
- [内存模型指南](../../guides/memory_model.mdx) - 深入理解 view、浅拷贝、深拷贝
- [性能优化建议](../../guides/performance_tips.mdx) - 避免不必要的拷贝
- [YTensorBase 内存管理](../../YTensorBase/construction/memory.mdx) - 基类的内存操作
