# 形状操作：重塑

本文档介绍 `YTensorBase` 类的重塑方法，包括 `view()`、`reshape()`、`contiguous()`、`contiguous_()` 和 `mostContinuousView()`。

## 概览

| 方法 | 要求连续 | 返回类型 | 可能拷贝 | 说明 |
| --- | --- | --- | --- | --- |
| `view()` | ✅ 必须 | 新视图 | ❌ 否 | 零拷贝重塑（仅连续张量） |
| `reshape()` | ❌ 否 | 新张量 | ✅ 可能 | 自动处理连续性 |
| `contiguous()` | ❌ 否 | 新张量 | ✅ 可能 | 返回连续副本 |
| `contiguous_()` | ❌ 否 | 自身引用 | ✅ 可能 | 原地转换为连续 |
| `mostContinuousView()` | ❌ 否 | 新视图 | ❌ 否 | 返回最连续的维度排列 |

---

## `view()`

### 函数签名

```cpp
YTensorBase view(const std::vector<int>& newShape) const;

template<typename... Args>
YTensorBase view(const Args... newShape) const;
```

### 参数说明

| 参数名 | 类型 | 说明 |
| --- | --- | --- |
| `newShape` | `std::vector<int>` 或 `Args...` | 新的形状。支持 `-1` 自动推断一个维度。 |

### 核心功能描述

返回新形状的视图（零拷贝）。
*   **要求张量必须是连续的**，否则抛出 `std::runtime_error` 异常。
*   支持 `-1` 自动推断一个维度。

### 返回值

- **类型**: `YTensorBase`
- **说明**: 返回新形状的视图（零拷贝）
- **要求**: **张量必须是连续的**，否则抛出 `std::runtime_error` 异常

### 使用示例

```cpp
#include "ytensor_single.hpp"

void example() {
    YTensorBase mat = YTensorBase::zeros({3, 4}, "float32");
    
    // 重塑为 [2, 6]
    YTensorBase reshaped = mat.view({2, 6});
    // reshaped.shape() -> {2, 6}
    
    // 使用 -1 自动推断
    YTensorBase auto_shape = mat.view({-1, 2});  // {6, 2}
}
```

---

## `reshape()`

### 函数签名

```cpp
YTensorBase reshape(const std::vector<int>& newShape) const;

template<typename... Args>
YTensorBase reshape(const Args... newShape) const;
```

### 核心功能描述

自动处理连续性的重塑操作。
*   等价于 `contiguous().view(newShape)`。
*   如果已连续，零拷贝；否则创建副本。

### 使用示例

```cpp
YTensorBase mat = YTensorBase::zeros({3, 4}, "float32");

// 非连续张量也可以 reshape
YTensorBase transposed = mat.transpose();
YTensorBase reshaped = transposed.reshape({2, 6});  // 自动创建副本
```

### view() vs reshape()

| 特性 | view() | reshape() |
| --- | --- | --- |
| **连续性要求** | ✅ 必须连续 | ❌ 无要求 |
| **可能拷贝** | ❌ 永不拷贝 | ✅ 可能拷贝 |
| **性能** | 快 | 较快 |
| **使用场景** | 确定连续时 | 不确定连续时 |

---

## `contiguous()`

### 函数签名

```cpp
YTensorBase contiguous() const;
```

### 核心功能描述

返回张量的连续版本。
*   按行优先（C风格）顺序重新排列元素。
*   如果已经连续，返回浅拷贝（共享内存）；否则创建深拷贝。

### 使用示例

```cpp
YTensorBase mat = YTensorBase::zeros({3, 4}, "float32");
YTensorBase transposed = mat.transpose();

// 非连续张量转为连续
YTensorBase c = transposed.contiguous();
std::cout << c.isContiguous() << std::endl;  // true
```

---

## `contiguous_()`

### 函数签名

```cpp
YTensorBase& contiguous_();
```

### 核心功能描述

原地转换为连续张量。
*   如果已连续，不做任何操作。
*   否则创建新的连续副本并替换当前对象。

### 使用示例

```cpp
YTensorBase tensor = YTensorBase::zeros({3, 4}, "float32");
tensor = tensor.transpose();  // 非连续

tensor.contiguous_();  // 原地转换
std::cout << tensor.isContiguous() << std::endl;  // true
```

---

## `mostContinuousView()`

### 函数签名

```cpp
YTensorBase mostContinuousView() const;
```

### 核心功能描述

返回张量的最连续视图。
*   通过按步长大小排序重排维度，并将负步长转换为正步长。
*   用于优化性能密集型操作。

### 使用示例

```cpp
YTensorBase tensor = YTensorBase::zeros({3, 4, 5}, "float32");
YTensorBase sliced = tensor.slice(0, 0, 2).slice(1, 1, 3);

YTensorBase mcv = sliced.mostContinuousView();
int cFrom = mcv.isContiguousFrom();
```

---

## -1 自动推断

`view()` 和 `reshape()` 支持使用 `-1` 自动推断一个维度：

```cpp
YTensorBase mat = YTensorBase::zeros({3, 4}, "float32");  // size = 12

// -1 自动推断
YTensorBase a = mat.reshape({-1, 2});  // {6, 2}
YTensorBase b = mat.reshape({2, -1});  // {2, 6}
```

:::tip
只能有一个 `-1`，且总元素数必须能被其他维度整除。
:::

---

## 注意事项

:::warning
**view() 要求连续**

对非连续张量调用 `view()` 会抛出异常：
```cpp
YTensorBase transposed = mat.transpose();
// YTensorBase bad = transposed.view({4, 3});  // ❌ 抛出异常

// ✅ 正确做法
YTensorBase good = transposed.contiguous().view({4, 3});
// 或者直接使用 reshape()
YTensorBase also_good = transposed.reshape({4, 3});
```
:::

---

## 相关内容

- [形状查询](./query.mdx) - `isContiguous()` 方法
- [形状操作：切片](./slice.mdx) - `slice()` 方法
- [形状操作：转置](./transpose.mdx) - `transpose()` 和 `permute()` 方法
- [内存管理](../construction/memory.mdx) - `clone()` 方法
