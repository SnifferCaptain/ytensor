# æ„é€ å‡½æ•°

æœ¬æ–‡æ¡£ä»‹ç» YTensorBase çš„æ„é€ å‡½æ•°ï¼ŒåŒ…æ‹¬é»˜è®¤æ„é€ ã€å½¢çŠ¶æ„é€ å’Œæ‹·è´æ„é€ ã€‚

---

## æ¦‚è¿°

YTensorBase æä¾›ä¸‰ç§æ„é€ æ–¹å¼ï¼š

```cpp
// 1. é»˜è®¤æ„é€ ï¼ˆç©ºå¼ é‡ï¼‰
YTensorBase a;

// 2. å½¢çŠ¶å’Œç±»å‹æ„é€ 
YTensorBase b({2, 3, 4}, "float32");

// 3. æ‹·è´æ„é€ ï¼ˆæ·±æ‹·è´ï¼‰
YTensorBase c = b;
```

---

## é»˜è®¤æ„é€ å‡½æ•°

### æ ¸å¿ƒåŠŸèƒ½æè¿°

åˆ›å»ºä¸€ä¸ªç©ºå¼ é‡ï¼Œä¸åˆ†é…å†…å­˜ã€‚

### å‡½æ•°ç­¾å

```cpp
YTensorBase() = default;
```

### ä½¿ç”¨ç¤ºä¾‹

```cpp
#include "ytensor_single.hpp"

int main() {

    
    yt::YTensorBase tensor;
    
    // æŸ¥è¯¢å±æ€§
    std::cout << tensor.ndim() << std::endl;    // 0
    std::cout << tensor.size() << std::endl;    // 0
    
    return 0;
}
```

---

## å½¢çŠ¶æ„é€ å‡½æ•°

### æ ¸å¿ƒåŠŸèƒ½æè¿°

ä½¿ç”¨æŒ‡å®šå½¢çŠ¶å’Œæ•°æ®ç±»å‹åˆ›å»ºå¼ é‡ã€‚

### å‡½æ•°ç­¾å

```cpp
YTensorBase(const std::vector<int>& shape, const std::string& dtype = "float32");
```

### å‚æ•°è¯´æ˜

| å‚æ•°å | ç±»å‹ | é»˜è®¤å€¼ | è¯´æ˜ |
|--------|------|--------|------|
| `shape` | `const std::vector<int>&` | - | å¼ é‡å½¢çŠ¶ |
| `dtype` | `const std::string&` | `"float32"` | æ•°æ®ç±»å‹å­—ç¬¦ä¸² |

### æ”¯æŒçš„æ•°æ®ç±»å‹

| dtype å­—ç¬¦ä¸² | C++ ç±»å‹ | å­—èŠ‚æ•° |
|--------------|----------|--------|
| `"float32"` | `float` | 4 |
| `"float64"` | `double` | 8 |
| `"int32"` | `int32_t` | 4 |
| `"int64"` | `int64_t` | 8 |
| `"int8"` | `int8_t` | 1 |
| `"uint8"` | `uint8_t` | 1 |
| `"bool"` | `bool` | 1 |

### å†…å­˜åˆ†é…

æ„é€ å‡½æ•°ä¼šï¼š
1. è®¡ç®—è¿ç»­å­˜å‚¨æ‰€éœ€çš„æ€»å…ƒç´ æ•°
2. åˆ†é… `total * elementSize` å­—èŠ‚å†…å­˜
3. åˆå§‹åŒ–æ­¥å¹…ä¸ºè¡Œä¼˜å…ˆï¼ˆC é£æ ¼ï¼‰
4. è®¾ç½®åç§»é‡ä¸º 0

### ä½¿ç”¨ç¤ºä¾‹

#### åŸºæœ¬ç”¨æ³•

```cpp


// float32 å¼ é‡ï¼ˆé»˜è®¤ï¼‰
auto a = yt::YTensorBase({2, 3, 4});
std::cout << a.dtype() << std::endl;        // "float32"
std::cout << a.elementSize() << std::endl;  // 4

// int32 å¼ é‡
auto b = yt::YTensorBase({10, 20}, "int32");
std::cout << b.size() << std::endl;  // 200

// double å¼ é‡
auto c = yt::YTensorBase({5, 5}, "float64");
std::cout << c.elementSize() << std::endl;  // 8
```

#### ä¸åŒç»´åº¦

```cpp
// ä¸€ç»´å¼ é‡
auto vec = yt::YTensorBase({100}, "float32");

// äºŒç»´å¼ é‡
auto mat = yt::YTensorBase({10, 20}, "float32");

// ä¸‰ç»´å¼ é‡
auto cube = yt::YTensorBase({5, 10, 15}, "float32");

// é«˜ç»´å¼ é‡
auto tensor = yt::YTensorBase({2, 3, 4, 5, 6}, "float32");
```

#### æ­¥å¹…è®¡ç®—

```cpp
auto a = yt::YTensorBase({2, 3, 4}, "float32");

auto stride = a.stride();
// stride = {12, 4, 1}  ï¼ˆè¡Œä¼˜å…ˆé¡ºåºï¼‰

// è®¡ç®—å…¬å¼ï¼š
// stride[2] = 1
// stride[1] = stride[2] * shape[2] = 1 * 4 = 4
// stride[0] = stride[1] * shape[1] = 4 * 3 = 12
```

---

## æ‹·è´æ„é€ å‡½æ•°

### æ ¸å¿ƒåŠŸèƒ½æè¿°

åˆ›å»ºç°æœ‰å¼ é‡çš„æ·±æ‹·è´ã€‚

### å‡½æ•°ç­¾å

```cpp
YTensorBase(const YTensorBase& other);
```

### å‚æ•°è¯´æ˜

| å‚æ•°å | ç±»å‹ | è¯´æ˜ |
|--------|------|------|
| `other` | `const YTensorBase&` | è¦æ‹·è´çš„æºå¼ é‡ |

### æ‹·è´è¡Œä¸º

æ‹·è´æ„é€ å‡½æ•°æ‰§è¡Œ**æ·±æ‹·è´**ï¼š
- å¤åˆ¶å½¢çŠ¶ã€æ­¥å¹…ã€åç§»é‡
- **å…±äº«**åº•å±‚æ•°æ®æŒ‡é’ˆï¼ˆ`std::shared_ptr`ï¼‰
- æ•°æ®æœ¬èº«ä¸è¢«å¤åˆ¶

:::warning
**æ³¨æ„**

YTensorBase çš„æ‹·è´æ„é€ æ˜¯**æµ…æ‹·è´**ï¼ˆå…±äº«æ•°æ®ï¼‰ï¼Œè€Œéæ·±æ‹·è´ã€‚è¦åˆ›å»ºç‹¬ç«‹å‰¯æœ¬ï¼Œä½¿ç”¨ `clone()`ã€‚

```cpp
yt::YTensorBase a({2, 3}, "float32");
yt::YTensorBase b = a;  // æµ…æ‹·è´ï¼ˆå…±äº«æ•°æ®ï¼‰

a.at<float>(0, 0) = 1.0f;
// b.at<float>(0, 0) == 1.0f  âœ… å…±äº«æ•°æ®

// æ·±æ‹·è´
yt::YTensorBase c = a.clone();
a.at<float>(0, 0) = 2.0f;
// c.at<float>(0, 0) == 1.0f  âœ… ç‹¬ç«‹æ•°æ®
```
:::

### ä½¿ç”¨ç¤ºä¾‹

#### åŸºæœ¬æ‹·è´

```cpp
auto a = yt::YTensorBase({2, 3}, "float32");
a.at<float>(0, 0) = 1.0f;

// æ‹·è´æ„é€ 
yt::YTensorBase b = a;

std::cout << b.at<float>(0, 0) << std::endl;  // 1.0

// å…±äº«æ•°æ®éªŒè¯
a.at<float>(0, 0) = 2.0f;
std::cout << b.at<float>(0, 0) << std::endl;  // 2.0ï¼ˆå…±äº«ï¼‰
```

#### å­˜å‚¨åˆ°å®¹å™¨

```cpp
std::vector<yt::YTensorBase> tensors;

auto a = yt::YTensorBase({2, 3}, "float32");
auto b = yt::YTensorBase({4, 5}, "int32");

// æ‹·è´æ„é€ 
tensors.push_back(a);
tensors.push_back(b);

// åŸå¼ é‡å’Œå®¹å™¨ä¸­çš„å¼ é‡å…±äº«æ•°æ®
a.at<float>(0, 0) = 1.0f;
std::cout << tensors[0].at<float>(0, 0) << std::endl;  // 1.0
```

---

## æ‹·è´èµ‹å€¼è¿ç®—ç¬¦

### æ ¸å¿ƒåŠŸèƒ½æè¿°

å°†ä¸€ä¸ªå¼ é‡èµ‹å€¼ç»™å¦ä¸€ä¸ªå¼ é‡ã€‚

### å‡½æ•°ç­¾å

```cpp
YTensorBase& operator=(const YTensorBase& other);
```

### å‚æ•°è¯´æ˜

| å‚æ•°å | ç±»å‹ | è¯´æ˜ |
|--------|------|------|
| `other` | `const YTensorBase&` | è¦èµ‹å€¼çš„æºå¼ é‡ |

### è¿”å›å€¼

è¿”å›å½“å‰å¯¹è±¡çš„å¼•ç”¨ã€‚

### èµ‹å€¼è¡Œä¸º

ä¸æ‹·è´æ„é€ ç›¸åŒï¼Œæ‰§è¡Œ**æµ…æ‹·è´**ï¼ˆå…±äº«æ•°æ®ï¼‰ã€‚

### ä½¿ç”¨ç¤ºä¾‹

```cpp
auto a = yt::YTensorBase({2, 3}, "float32");
auto b = yt::YTensorBase({4, 5}, "int32");

// èµ‹å€¼è¿ç®—ç¬¦
b = a;  // b ç°åœ¨ä¸ a å…±äº«æ•°æ®

std::cout << b.shape(0) << std::endl;  // 2
std::cout << b.dtype() << std::endl;   // "float32"
```

---

## é POD ç±»å‹æ”¯æŒ

YTensorBase æ”¯æŒé PODï¼ˆPlain Old Dataï¼‰ç±»å‹ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨æ„é€ å‡½æ•°å’Œææ„å‡½æ•°ã€‚

### è‡ªå®šä¹‰ç±»å‹

```cpp
struct MyType {
    float value;
    
    MyType() : value(0.0f) {
        std::cout << "MyType constructed" << std::endl;
    }
    
    ~MyType() {
        std::cout << "MyType destructed" << std::endl;
    }
};

// æ³¨å†Œç±»å‹ï¼ˆéœ€è¦åœ¨ ytensor_types.hpp ä¸­æ³¨å†Œï¼‰
// auto tensor = yt::YTensorBase({2, 3}, "MyType");
// æ„é€ æ—¶ä¼šè°ƒç”¨ MyType() æ„é€ å‡½æ•°
// ææ„æ—¶ä¼šè°ƒç”¨ ~MyType() ææ„å‡½æ•°
```

### POD ç±»å‹ä¼˜åŒ–

å¯¹äº POD ç±»å‹ï¼ˆå¦‚ `float`, `int`ï¼‰ï¼ŒYTensorBase ä½¿ç”¨ç®€å•çš„å†…å­˜åˆ†é…ï¼Œä¸è°ƒç”¨æ„é€ å‡½æ•°ï¼š

```cpp
// POD ç±»å‹ï¼šå¿«é€Ÿåˆ†é…
auto a = yt::YTensorBase({1000, 1000}, "float32");
// åªåˆ†é…å†…å­˜ï¼Œä¸åˆå§‹åŒ–

// é POD ç±»å‹ï¼šè°ƒç”¨æ„é€ å‡½æ•°
// auto b = yt::YTensorBase({1000, 1000}, "CustomType");
// ä¸ºæ¯ä¸ªå…ƒç´ è°ƒç”¨æ„é€ å‡½æ•°
```

---

## å†…å­˜ç®¡ç†

### å¼•ç”¨è®¡æ•°

YTensorBase ä½¿ç”¨ `std::shared_ptr<char[]>` ç®¡ç†æ•°æ®ï¼Œæ”¯æŒè‡ªåŠ¨å¼•ç”¨è®¡æ•°ï¼š

```cpp
auto a = yt::YTensorBase({2, 3}, "float32");

{
    yt::YTensorBase b = a;  // å¼•ç”¨è®¡æ•° +1
    yt::YTensorBase c = a;  // å¼•ç”¨è®¡æ•° +1
    // b, c ç¦»å¼€ä½œç”¨åŸŸï¼Œå¼•ç”¨è®¡æ•° -2
}

// a ä»ç„¶æœ‰æ•ˆï¼Œå¼•ç”¨è®¡æ•° = 1
```

### è‡ªåŠ¨é‡Šæ”¾

å½“æœ€åä¸€ä¸ªå¼•ç”¨ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå†…å­˜è‡ªåŠ¨é‡Šæ”¾ï¼š

```cpp
{
    auto a = yt::YTensorBase({1000, 1000}, "float32");
    // åˆ†é… 4MB å†…å­˜
} // a ç¦»å¼€ä½œç”¨åŸŸï¼Œå†…å­˜è‡ªåŠ¨é‡Šæ”¾
```

---

## å¼‚å¸¸å®‰å…¨

### å½¢çŠ¶éªŒè¯

```cpp
// âŒ ç©ºå½¢çŠ¶
try {
    auto a = yt::YTensorBase({}, "float32");
    // åˆ›å»º 0 ç»´å¼ é‡ï¼ˆå…è®¸ï¼‰
} catch (...) {
    // ä¸ä¼šæŠ›å‡ºå¼‚å¸¸
}

// âœ… è´Ÿæ•°å½¢çŠ¶
auto b = yt::YTensorBase({2, -3, 4}, "float32");
// è´Ÿæ•°è¢«è§†ä¸º 0ï¼Œæ€»å…ƒç´ æ•° = 0ï¼Œåˆ†é… 1 å­—èŠ‚
```

### ç±»å‹éªŒè¯

```cpp
// âŒ æœªçŸ¥ç±»å‹
try {
    auto a = yt::YTensorBase({2, 3}, "unknown_type");
    // æŠ›å‡ºå¼‚å¸¸æˆ–è¿”å› 0
} catch (const std::exception& e) {
    std::cerr << e.what() << std::endl;
}
```

---

## æ€§èƒ½è€ƒè™‘

### æ„é€ æˆæœ¬

```cpp
// å°å¼ é‡ï¼šå¿«é€Ÿ
auto a = yt::YTensorBase({10, 10}, "float32");  // ~400 å­—èŠ‚

// å¤§å¼ é‡ï¼šè¾ƒæ…¢
auto b = yt::YTensorBase({1000, 1000}, "float32");  // ~4MB
```

### æ‹·è´æˆæœ¬

```cpp
// æµ…æ‹·è´ï¼šO(1)
auto a = yt::YTensorBase({1000, 1000}, "float32");
auto b = a;  // åªå¤åˆ¶æŒ‡é’ˆï¼Œéå¸¸å¿«

// æ·±æ‹·è´ï¼šO(n)
auto c = a.clone();  // å¤åˆ¶æ‰€æœ‰æ•°æ®ï¼Œè¾ƒæ…¢
```

---

## ä½¿ç”¨ç¤ºä¾‹æ±‡æ€»

### åˆ›å»ºä¸åŒç±»å‹å¼ é‡

```cpp


// æµ®ç‚¹å¼ é‡
auto float_tensor = yt::YTensorBase({10, 20}, "float32");
auto double_tensor = yt::YTensorBase({10, 20}, "float64");

// æ•´æ•°å¼ é‡
auto int_tensor = yt::YTensorBase({10, 20}, "int32");
auto long_tensor = yt::YTensorBase({10, 20}, "int64");

// å¸ƒå°”å¼ é‡
auto bool_tensor = yt::YTensorBase({10, 20}, "bool");
```

### æ‰¹é‡åˆ›å»º

```cpp
std::vector<yt::YTensorBase> create_batch(int batch_size, 
                                       const std::vector<int>& shape,
                                       const std::string& dtype) {
    std::vector<yt::YTensorBase> batch;
    for (int i = 0; i < batch_size; i++) {
        batch.emplace_back(shape, dtype);
    }
    return batch;
}

// ä½¿ç”¨
auto batch = create_batch(32, {3, 224, 224}, "float32");
```

### ç±»å‹è½¬æ¢

```cpp
yt::YTensorBase convert_dtype(const yt::YTensorBase& src, const std::string& new_dtype) {
    yt::YTensorBase dst(src.shape(), new_dtype);
    
    // é€å…ƒç´ è½¬æ¢ï¼ˆéœ€è¦æ ¹æ®ç±»å‹åˆ†å‘ï¼‰
    if (src.dtype() == "float32" && new_dtype == "int32") {
        const float* src_data = src.data<float>();
        int* dst_data = dst.data<int>();
        for (size_t i = 0; i < src.size(); i++) {
            dst_data[i] = static_cast<int>(src_data[i]);
        }
    }
    
    return dst;
}
```

---

## æœ€ä½³å®è·µ

### 1. ä½¿ç”¨é»˜è®¤ç±»å‹

```cpp
// âœ… é»˜è®¤ float32ï¼ˆæœ€å¸¸ç”¨ï¼‰
auto tensor = yt::YTensorBase({10, 20});

// ğŸ”¶ ä»…åœ¨å¿…è¦æ—¶æŒ‡å®šå…¶ä»–ç±»å‹
auto int_tensor = yt::YTensorBase({10, 20}, "int32");
```

### 2. é¿å…ä¸å¿…è¦çš„æ‹·è´

```cpp
// âŒ ä¸å¿…è¦çš„æ‹·è´
yt::YTensorBase func() {
    yt::YTensorBase tensor({10, 20}, "float32");
    return tensor;  // å¯èƒ½è§¦å‘æ‹·è´
}

// âœ… ç§»åŠ¨è¯­ä¹‰
yt::YTensorBase func() {
    yt::YTensorBase tensor({10, 20}, "float32");
    return std::move(tensor);  // ç§»åŠ¨ï¼Œä¸æ‹·è´
}
```

### 3. ä½¿ç”¨ emplace_back

```cpp
std::vector<yt::YTensorBase> tensors;

// âŒ ä¸å¿…è¦çš„æ‹·è´
yt::YTensorBase temp({10, 20}, "float32");
tensors.push_back(temp);

// âœ… åŸåœ°æ„é€ 
tensors.emplace_back(std::vector<int>{10, 20}, "float32");
```

---

## ç›¸å…³å†…å®¹

- [å·¥å‚æ–¹æ³•](./factories.mdx) - zeros, ones ç­‰ä¾¿æ·æ„é€ 
- [å†…å­˜ç®¡ç†](./memory.mdx) - clone, contiguous
- [YTensor æ„é€ å‡½æ•°](../../YTensor/construction/constructors.mdx) - ç¼–è¯‘æ—¶ç±»å‹ç‰ˆæœ¬
- [ç±»å‹ç³»ç»Ÿ](../../infos/types.mdx) - dtype æ³¨å†Œæœºåˆ¶
