# YTensorBase 概览

YTensorBase 是 YTensor 库的**运行时多态基类**，提供类型擦除的张量接口。

---

## 概述

YTensorBase 与 YTensor 的关系：

```cpp
// YTensor: 编译时类型安全
YTensor<float, 3> a({2, 3, 4});  // 类型和维度在编译时确定

// YTensorBase: 运行时多态
YTensorBase b({2, 3, 4}, "float32");  // 类型和维度在运行时确定
```

### 核心特性

- **运行时类型**：通过字符串指定数据类型（"float32", "int32" 等）
- **运行时维度**：维度数量在运行时确定
- **类型擦除**：所有类型共享统一接口
- **与 YTensor 兼容**：可以相互转换

---

## 为什么需要 YTensorBase？

### 1. 动态类型场景

```cpp
// ❌ YTensor 无法处理运行时类型
std::string user_dtype = get_user_input();  // "float32" 或 "int32"?
// YTensor<???, 3> tensor;  // 无法在编译时决定

// ✅ YTensorBase 支持运行时类型
YTensorBase tensor({2, 3, 4}, user_dtype);
```

### 2. 异构容器

```cpp
// ❌ YTensor 难以存储不同类型
std::vector<YTensor<???, ???>> tensors;  // 类型不一致

// ✅ YTensorBase 可以统一存储
std::vector<YTensorBase> tensors;
tensors.push_back(YTensorBase({2, 3}, "float32"));
tensors.push_back(YTensorBase({4, 5}, "int32"));
tensors.push_back(YTensorBase({1, 2, 3}, "double"));
```

### 3. 序列化/反序列化

```cpp
// 从文件加载张量（运行时才知道类型和维度）
YTensorBase load_tensor(const std::string& filename) {
    auto info = read_header(filename);
    return YTensorBase(info.shape, info.dtype);
}
```

### 4. 与 Python 交互

```cpp
// Python 传来的张量类型未知
YTensorBase from_python(PyObject* obj) {
    auto shape = extract_shape(obj);
    auto dtype = extract_dtype(obj);  // 运行时确定
    return YTensorBase(shape, dtype);
}
```

---

## YTensorBase vs YTensor

| 特性 | YTensor\<T, dim\> | YTensorBase |
|------|----------------|-------------|
| 类型检查 | **编译时** | 运行时 |
| 维度检查 | **编译时** | 运行时 |
| 性能 | **更快**（内联、优化） | 稍慢（虚函数、类型擦除）|
| 灵活性 | 类型固定 | **类型动态** |
| 存储 | 不同类型不兼容 | **统一接口** |
| 安全性 | **编译期保证** | 运行期检查 |
| 适用场景 | 性能关键、类型已知 | **类型未知、异构存储** |

---

## 支持的数据类型

YTensorBase 通过字符串指定数据类型：

### 基本类型

| dtype 字符串 | C++ 类型 | 字节数 | 说明 |
|--------------|----------|--------|------|
| `"float32"` | `float` | 4 | 单精度浮点（默认）|
| `"float64"` | `double` | 8 | 双精度浮点 |
| `"int32"` | `int32_t` | 4 | 32位有符号整数 |
| `"int64"` | `int64_t` | 8 | 64位有符号整数 |
| `"int8"` | `int8_t` | 1 | 8位有符号整数 |
| `"uint8"` | `uint8_t` | 1 | 8位无符号整数 |
| `"bool"` | `bool` | 1 | 布尔类型 |

### 使用示例

```cpp
#include "ytensor_single.hpp"

int main() {

    
    // 不同数据类型
    auto a = yt::YTensorBase({2, 3}, "float32");
    auto b = yt::YTensorBase({4, 5}, "int32");
    auto c = yt::YTensorBase({10}, "double");
    
    // 查询类型
    std::cout << a.dtype() << std::endl;  // "float32"
    std::cout << b.dtype() << std::endl;  // "int32"
    
    // 查询元素大小
    std::cout << a.elementSize() << std::endl;  // 4
    std::cout << b.elementSize() << std::endl;  // 4
    std::cout << c.elementSize() << std::endl;  // 8
    
    return 0;
}
```

---

## 基本操作

### 构造

```cpp
// 1. 指定形状和类型
YTensorBase a({2, 3, 4}, "float32");

// 2. 拷贝构造
YTensorBase b = a;  // 深拷贝

// 3. 工厂方法
auto zeros = YTensorBase::zeros({2, 3}, "float32");
auto ones = YTensorBase::ones({4, 5}, "int32");
```

### 访问元素

```cpp
auto a = YTensorBase({2, 3}, "float32");

// 需要指定类型模板参数
float& val = a.at<float>(1, 2);
val = 3.14f;

// 常量访问
const float& val2 = static_cast<const YTensorBase&>(a).at<float>(1, 2);
```

### 形状操作

```cpp
auto a = YTensorBase({2, 3, 4}, "float32");

// 查询形状
auto shape = a.shape();  // std::vector<int>{2, 3, 4}
int dim1 = a.shape(1);   // 3
int ndim = a.ndim();     // 3

// 切片
auto sliced = a.slice(0, 0, 1);  // 取第一行

// 转置
auto transposed = a.transpose(0, 1);

// 变形
auto reshaped = a.view({6, 4});
```

---

## 与 YTensor 的互操作

### YTensor → YTensorBase

YTensor 继承自 YTensorBase，可以隐式转换：

```cpp
YTensor<float, 3> a({2, 3, 4});

// 隐式转换
YTensorBase b = a;  // ✅ 深拷贝

// 引用（避免拷贝）
YTensorBase& ref = a;  // ✅ 引用同一对象
```

### YTensorBase → YTensor

需要显式构造，类型和维度必须匹配：

```cpp
YTensorBase a({2, 3, 4}, "float32");

// ✅ 类型和维度匹配
YTensor<float, 3> b(a.shape());
b.copy_(a);

// ❌ 类型或维度不匹配会导致未定义行为
// YTensor<int, 3> c(a.shape());
// c.copy_(a);  // ⚠️ 类型不匹配

// ❌ 维度不匹配
// YTensor<float, 2> d({2, 3});
// d.copy_(a);  // ❌ 形状不匹配
```

---

## 内存模型

YTensorBase 与 YTensor 共享相同的内存模型：

### 共享底层数据

```cpp
YTensorBase a({2, 3, 4}, "float32");
YTensorBase b = a;  // 深拷贝（独立数据）

auto c = a.slice(0, 0, 1);  // 浅拷贝（共享数据）
c.at<float>(0, 0, 0) = 1.0f;
// a.at<float>(0, 0, 0) == 1.0f  ✅ 共享
```

### 连续性

```cpp
auto a = YTensorBase({2, 3, 4}, "float32");
std::cout << a.isContiguous() << std::endl;  // true

auto b = a.transpose();
std::cout << b.isContiguous() << std::endl;  // false

// 转换为连续张量
auto c = b.contiguous();
std::cout << c.isContiguous() << std::endl;  // true
```

### 引用计数

```cpp
YTensorBase a({2, 3, 4}, "float32");
YTensorBase b = a;  // 深拷贝

// 修改 b 不影响 a
b.at<float>(0, 0, 0) = 1.0f;
// a.at<float>(0, 0, 0) != 1.0f  ✅ 独立
```

---

## 运行时类型安全

### 类型检查

```cpp
YTensorBase a({2, 3}, "float32");

// ✅ 正确类型
float val = a.at<float>(0, 0);

// ❌ 错误类型（未定义行为）
// int val2 = a.at<int>(0, 0);  // ⚠️ 类型不匹配
```

### 安全访问模式

```cpp
template <typename T>
void process(YTensorBase& tensor) {
    // 检查类型
    std::string expected_dtype;
    if constexpr (std::is_same_v<T, float>) {
        expected_dtype = "float32";
    } else if constexpr (std::is_same_v<T, int>) {
        expected_dtype = "int32";
    }
    
    if (tensor.dtype() != expected_dtype) {
        throw std::invalid_argument("Type mismatch");
    }
    
    // 安全访问
    for (size_t i = 0; i < tensor.size(); i++) {
        auto coord = tensor.toCoord(i);
        T& val = tensor.at<T>(coord);
        // 处理 val
    }
}
```

---

## 性能考虑

### 虚函数开销

YTensorBase 使用虚函数实现多态，有少量性能开销：

```cpp
// YTensor: 内联优化
YTensor<float, 3> a({100, 100, 100});
for (int i = 0; i < 100; i++) {
    a.at(i, i, i) = 1.0f;  // 编译器可内联
}

// YTensorBase: 虚函数调用
YTensorBase b({100, 100, 100}, "float32");
for (int i = 0; i < 100; i++) {
    b.at<float>(i, i, i) = 1.0f;  // 虚函数开销
}
```

**基准测试**（1M 次访问）：
- YTensor: ~45ms
- YTensorBase: ~52ms（~15% 开销）

### 优化建议

```cpp
// ❌ 低效：频繁类型检查
YTensorBase tensor({1000, 1000}, "float32");
for (size_t i = 0; i < tensor.size(); i++) {
    if (tensor.dtype() == "float32") {  // 每次都检查
        auto coord = tensor.toCoord(i);
        tensor.at<float>(coord) = 0.0f;
    }
}

// ✅ 高效：提前检查类型
if (tensor.dtype() == "float32") {
    float* data = tensor.data<float>();
    for (size_t i = 0; i < tensor.size(); i++) {
        data[i] = 0.0f;  // 直接指针访问
    }
}
```

---

## 使用场景

### 1. 动态类型推断

```cpp
YTensorBase load_and_process(const std::string& path) {
    auto tensor = load_from_file(path);  // 类型未知
    
    if (tensor.dtype() == "float32") {
        // 浮点处理
        return process_float(tensor);
    } else if (tensor.dtype() == "int32") {
        // 整数处理
        return process_int(tensor);
    }
    
    throw std::runtime_error("Unsupported dtype");
}
```

### 2. 通用容器

```cpp
class Model {
    std::map<std::string, YTensorBase> parameters;
    
public:
    void add_param(const std::string& name, const YTensorBase& param) {
        parameters[name] = param;
    }
    
    YTensorBase& get_param(const std::string& name) {
        return parameters.at(name);
    }
};

// 使用
Model model;
model.add_param("weight", YTensorBase({128, 256}, "float32"));
model.add_param("bias", YTensorBase({256}, "float32"));
model.add_param("mask", YTensorBase({10, 10}, "bool"));
```

### 3. 类型分发

```cpp
void universal_fill(YTensorBase& tensor, double value) {
    if (tensor.dtype() == "float32") {
        float* data = tensor.data<float>();
        std::fill_n(data, tensor.size(), static_cast<float>(value));
    } else if (tensor.dtype() == "int32") {
        int* data = tensor.data<int>();
        std::fill_n(data, tensor.size(), static_cast<int>(value));
    } else if (tensor.dtype() == "double") {
        double* data = tensor.data<double>();
        std::fill_n(data, tensor.size(), value);
    }
}
```

---

## 常见陷阱

### 1. 类型模板参数遗漏

```cpp
YTensorBase a({2, 3}, "float32");

// ❌ 忘记类型参数
// auto val = a.at(0, 0);  // 编译错误

// ✅ 必须指定类型
auto val = a.at<float>(0, 0);
```

### 2. 类型不匹配

```cpp
YTensorBase a({2, 3}, "float32");

// ❌ 错误类型（未定义行为）
// int val = a.at<int>(0, 0);  // ⚠️ 读取到错误数据

// ✅ 使用 dtype() 检查
if (a.dtype() == "float32") {
    float val = a.at<float>(0, 0);
}
```

### 3. 维度假设错误

```cpp
void process_3d(YTensorBase& tensor) {
    // ❌ 假设是3维
    // tensor.at<float>(0, 0, 0);  // 如果是2维会越界
    
    // ✅ 检查维度
    if (tensor.ndim() != 3) {
        throw std::invalid_argument("Expected 3D tensor");
    }
    tensor.at<float>(0, 0, 0);
}
```

---

## API 组织

YTensorBase 的完整 API 按功能分类：

### 构造与内存
- [构造函数](./construction/constructors.mdx) - 基本构造方式
- [工厂方法](./construction/factories.mdx) - zeros, ones 等
- [内存管理](./construction/memory.mdx) - clone, contiguous

### 访问与索引
- [索引访问](./access/indexing.mdx) - at, atData, atData_
- [指针访问](./access/data_ptr.mdx) - data, data_
- [类型访问](./access/dtype.mdx) - dtype, elementSize

### 形状操作
- [形状查询](./shape/query.mdx) - shape, stride, size
- [切片操作](./shape/slice.mdx) - slice, slice_
- [变形操作](./shape/reshape.mdx) - view, reshape
- [转置操作](./shape/transpose.mdx) - transpose, permute
- [维度操作](./shape/dimension.mdx) - squeeze, unsqueeze
- [拼接分割](./shape/concat_split.mdx) - concat, split

### 数学运算
- [算术运算](./math/arithmetic.mdx) - +, -, *, /
- [广播操作](./math/broadcast.mdx) - 广播规则
- [矩阵乘法](./math/matmul.mdx) - matmul
- [归约操作](./math/reduction.mdx) - sum, mean, max

### 工具方法
- [坐标转换](./utilities/conversion.mdx) - toIndex, toCoord
- [属性查询](./utilities/properties.mdx) - isContiguous, isDisjoint

---

## 最佳实践

### 1. 明确类型场景

```cpp
// ✅ 类型已知 → 使用 YTensor
void process_known_type(const std::vector<float>& data) {
    YTensor<float, 2> tensor({10, 10});
    // 编译时类型安全
}

// ✅ 类型未知 → 使用 YTensorBase
void process_unknown_type(const std::string& dtype) {
    YTensorBase tensor({10, 10}, dtype);
    // 运行时灵活性
}
```

### 2. 提前类型检查

```cpp
// ✅ 入口处检查一次
void process(YTensorBase& tensor) {
    if (tensor.dtype() != "float32") {
        throw std::invalid_argument("Expected float32");
    }
    
    // 后续可安全使用
    float* data = tensor.data<float>();
    for (size_t i = 0; i < tensor.size(); i++) {
        data[i] *= 2.0f;
    }
}
```

### 3. 优先直接指针

```cpp
// ❌ 低效
YTensorBase tensor({1000, 1000}, "float32");
for (size_t i = 0; i < tensor.size(); i++) {
    auto coord = tensor.toCoord(i);
    tensor.at<float>(coord) = 0.0f;
}

// ✅ 高效
if (tensor.isContiguous()) {
    float* data = tensor.data<float>();
    std::fill_n(data, tensor.size(), 0.0f);
}
```

---

## 相关内容

- [YTensor 概览](../YTensor/overview.mdx) - 编译时类型安全版本
- [类型系统](../infos/types.mdx) - dtype 注册机制
- [内存模型](../guides/memory_model.mdx) - 深入理解内存布局
- [性能对比](../guides/performance_tips.mdx) - YTensor vs YTensorBase
