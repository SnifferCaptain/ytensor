# 属性查询

本文档介绍 `YTensorBase` 类的属性查询方法。

## 概述

| 方法 | 返回类型 | 说明 |
| --- | --- | --- |
| `isContiguous()` | `bool` | 检查从指定维度开始是否连续 |
| `isContiguousFrom()` | `int` | 获取从哪个维度开始连续 |
| `isDisjoint()` | `bool` | 检查元素是否不重叠 |
| `shapeMatch()` | `bool` | 检查形状是否匹配 |

---

## `isContiguous()`

### 函数签名

```cpp
bool isContiguous(int fromDim = 0, int toDim = -1) const;
```

### 参数说明

| 参数名 | 类型 | 默认值 | 说明 |
| --- | --- | --- | --- |
| `fromDim` | `int` | `0` | 从该维度开始检查（支持负数循环索引） |
| `toDim` | `int` | `-1` | 结束维度（不包含，支持负数循环索引），默认 `-1` 表示到最后一维（不含） |

### 核心功能描述

检查张量从指定维度开始是否内存连续。
*   连续意味着逻辑 stride 与实际 stride 一致。

### 返回值

- `true`: 从 `fromDim` 开始的所有维度都是连续的
- `false`: 存在不连续的维度，或 `_data` 为空

### 使用示例

```cpp
YTensorBase tensor = YTensorBase::zeros({3, 4, 5}, "float32");

bool cont0 = tensor.isContiguous();    // true（完全连续）
bool cont1 = tensor.isContiguous(1);   // true

YTensorBase t = tensor.transpose();
bool cont2 = t.isContiguous();         // false（转置破坏连续性）
bool cont3 = t.isContiguous(1);        // 可能 true（取决于具体情况）
```

---

## `isContiguousFrom()`

### 函数签名

```cpp
int isContiguousFrom() const;
```

### 核心功能描述

获取从哪个维度开始连续。

### 返回值

- **类型**: `int`
- **说明**: 返回从哪个维度开始是连续的
  - 返回 `0`：完全连续
  - 返回 `ndim()`：完全不连续（或 `_data` 为空）
  - 返回 `k`：从维度 k 开始连续（维度 0 到 k-1 可能不连续）

### 使用示例

```cpp
YTensorBase tensor = YTensorBase::zeros({3, 4, 5}, "float32");
int from0 = tensor.isContiguousFrom();  // 0（完全连续）

// 如果只检查前两个维度
bool cont4 = tensor.isContiguous(0, 2);
```

---

## `isContiguousFrom()`

### 函数签名

```cpp
int isContiguousFrom(int fromDim = 0, int toDim = -1) const;
```

### 参数说明

| 参数名 | 类型 | 默认值 | 说明 |
| --- | --- | --- | --- |
| `fromDim` | `int` | `0` | 起始维度（包含，支持负数循环索引） |
| `toDim` | `int` | `-1` | 结束维度（不包含，支持负数循环索引） |

### 核心功能描述

获取张量在指定范围内从哪个维度开始连续。

### 返回值

- **类型**: `int`
- **说明**: 返回范围内第一个不连续维度的索引+1，如果全部连续则返回 `fromDim`。
  - 基本逻辑：寻找最大的 `k` 使得从 `k` 到 `toDim` 是连续的。
  - 如果完全连续，返回 `fromDim`。
  - 如果完全不连续，返回 `toDim` 对应的正向索引。

### 使用示例

```cpp
YTensorBase tensor = YTensorBase::zeros({3, 4, 5}, "float32");
int from0 = tensor.isContiguousFrom();  // 0（完全连续）

YTensorBase t = tensor.transpose(-2, -1);
int from1 = t.isContiguousFrom();
// 可能返回 ndim() - 2 或更小的值
```

---

## `isDisjoint()`

### 函数签名

```cpp
bool isDisjoint() const;
```

### 核心功能描述

检查张量视图是否**不重叠**。
*   即每个逻辑位置对应唯一的内存位置。

### 返回值

- `true`: 元素不重叠
- `false`: 存在重叠（例如 stride 为 0 的 repeat 操作）

### 判断逻辑

对于每个维度 `d`（形状 > 1），检查：`|stride[d]| >= 理论最小跨度`

如果 `|stride[d]| < 理论最小跨度`，则存在重叠。

### 使用示例

```cpp
YTensorBase tensor = YTensorBase::zeros({3, 4}, "float32");
bool disj1 = tensor.isDisjoint();  // true

// repeat 创建重叠视图（stride 为 0）
YTensorBase t = YTensorBase::zeros({1, 4}, "float32").repeat({3, 1});
bool disj2 = t.isDisjoint();       // false（stride[0] = 0）
```

---

## `shapeMatch()`

### 函数签名

```cpp
bool shapeMatch(const std::vector<int>& otherShape) const;
```

### 核心功能描述

检查张量形状是否与给定形状**完全匹配**。

### 返回值

- `true`: 维度数相同且每个维度大小相同
- `false`: 维度数不同或任何维度大小不同

### 使用示例

```cpp
YTensorBase tensor = YTensorBase::zeros({3, 4, 5}, "float32");

bool match1 = tensor.shapeMatch({3, 4, 5});  // true
bool match2 = tensor.shapeMatch({3, 4});     // false（维度数不同）
bool match3 = tensor.shapeMatch({4, 3, 5});  // false（维度大小不同）
```

---

## 相关内容

- [形状查询](../shape/query.mdx) - `shape()`、`ndim()` 方法
- [形状操作：重塑](../shape/reshape.mdx) - `contiguous()` 方法
- [坐标转换](./conversion.mdx) - `toIndex()`、`toCoord()` 方法
